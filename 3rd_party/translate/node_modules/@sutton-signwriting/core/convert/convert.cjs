/**
* Sutton SignWriting Core Module v2.0.0 (https://github.com/sutton-signwriting/core)
* Author: Steve Slevinski  (https://SteveSlevinski.me)
* convert.cjs is released under the MIT License.
*/

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Object of regular expressions for FSW strings
 * 
 * @alias fsw.re
 * @property {string} null - the null symbol
 * @property {string} symbol - a symbol
 * @property {string} nullorsymbol - null or a symbol
 * @property {string} sort - the sorting marker
 * @property {string} prefix - a sorting marker followed by one or more symbols with nulls
 * @property {string} box - a signbox marker
 * @property {string} coord - a coordinate
 * @property {string} spatial - a symbol followed by a coordinate
 * @property {string} signbox - a signbox marker, max coordinate and zero or more spatial symbols
 * @property {string} sign - an optional prefix followed by a signbox
 * @property {string} sortable - a mandatory prefix followed by a signbox
 */
let re$1 = {
  'null': 'S00000',
  'symbol': 'S[123][0-9a-f]{2}[0-5][0-9a-f]',
  'coord': '[0-9]{3}x[0-9]{3}',
  'sort': 'A',
  'box': '[BLMR]'
};
re$1.nullorsymbol = `(?:${re$1.null}|${re$1.symbol})`;
re$1.prefix = `(?:${re$1.sort}${re$1.nullorsymbol}+)`;
re$1.spatial = `${re$1.symbol}${re$1.coord}`;
re$1.signbox = `${re$1.box}${re$1.coord}(?:${re$1.spatial})*`;
re$1.sign = `${re$1.prefix}?${re$1.signbox}`;
re$1.sortable = `${re$1.prefix}${re$1.signbox}`;

/**
 * Object of regular expressions for SWU strings in UTF-16
 * 
 * @alias swu.re
 * @property {string} null - the null symbol
 * @property {string} symbol - a symbol
 * @property {string} nullorsymbol - null or a symbol
 * @property {string} sort - the sorting marker
 * @property {string} prefix - a sorting marker followed by one or more symbols with nulls
 * @property {string} box - a signbox marker
 * @property {string} coord - a coordinate
 * @property {string} spatial - a symbol followed by a coordinate
 * @property {string} signbox - a signbox marker, max coordinate and zero or more spatial symbols
 * @property {string} sign - an optional prefix followed by a signbox
 * @property {string} sortable - a mandatory prefix followed by a signbox
 */
let re = {
  'null': '\uD8C0\uDC00',
  'symbol': '(?:(?:\uD8C0[\uDC01-\uDFFF])|(?:[\uD8C1-\uD8FC][\uDC00-\uDFFF])|(?:\uD8FD[\uDC00-\uDC80]))',
  'coord': '(?:\uD836[\uDC0C-\uDDFF]){2}',
  'sort': '\uD836\uDC00',
  'box': '\uD836[\uDC01-\uDC04]'
};
re.nullorsymbol = `(?:${re.null}|${re.symbol})`;
re.prefix = `(?:${re.sort}(?:${re.nullorsymbol})+)`;
re.spatial = `${re.symbol}${re.coord}`;
re.signbox = `${re.box}${re.coord}(?:${re.spatial})*`;
re.sign = `${re.prefix}?${re.signbox}`;
re.sortable = `${re.prefix}${re.signbox}`;

/**
 * An array of symbol IDs in minimized format such as "101011"
 * 
 * @alias convert.symidArr
 * @type {string[]}
 */
const symidArr = ["101011", "101021", "101031", "101041", "101051", "101061", "101071", "101081", "101091", "101101", "101111", "101121", "101131", "101141", "102011", "102021", "102031", "102041", "102051", "102061", "102071", "102081", "102091", "102101", "102111", "102121", "102131", "102141", "102151", "102161", "103011", "103021", "103031", "103041", "103051", "103061", "103071", "103081", "103091", "103101", "103111", "103121", "103131", "103141", "103151", "103161", "103171", "103181", "103191", "103201", "103211", "103221", "103231", "103241", "103251", "103261", "103271", "103281", "103291", "103301", "103311", "103321", "103331", "103341", "103351", "103361", "103371", "103381", "104011", "104021", "104031", "104041", "104051", "104061", "104071", "104081", "105011", "105021", "105031", "105041", "105051", "105061", "105071", "105081", "105091", "105101", "105111", "105121", "105131", "105141", "105151", "105161", "105171", "105181", "105191", "105201", "105211", "105221", "105231", "105241", "105251", "105261", "105271", "105281", "105291", "105301", "105311", "105321", "105331", "105341", "105351", "105361", "105371", "105381", "105391", "105401", "105411", "105421", "105431", "105441", "105451", "105461", "105471", "105481", "105491", "105501", "105511", "105521", "105531", "105541", "105551", "105561", "105571", "105581", "106011", "106021", "106031", "106041", "106051", "106061", "106071", "106081", "106091", "106101", "106111", "106121", "106131", "106141", "106151", "106161", "106171", "106181", "106191", "106201", "106211", "106221", "106231", "106241", "106251", "106261", "106271", "106281", "106291", "106301", "107011", "107021", "107031", "107041", "107051", "107061", "107071", "107081", "107091", "107101", "107111", "107121", "107131", "107141", "107151", "107161", "107171", "107181", "107191", "107201", "107211", "107221", "108011", "108021", "108031", "108041", "108051", "108061", "108071", "108081", "108091", "108101", "108111", "108121", "108131", "108141", "108151", "108161", "108171", "108181", "108191", "109011", "109021", "109031", "109041", "109051", "109061", "109071", "109081", "109091", "109101", "109111", "109121", "109131", "109141", "109151", "109161", "109171", "109181", "109191", "109201", "109211", "109221", "109231", "109241", "109251", "109261", "109271", "109281", "109291", "109301", "109311", "109321", "109331", "109341", "109351", "109361", "109371", "109381", "109391", "109401", "110011", "110021", "110031", "110041", "110051", "110061", "110071", "110081", "110091", "110101", "110111", "110121", "110131", "110141", "110151", "110161", "201011", "201021", "201031", "201041", "201051", "201061", "201071", "201081", "201091", "201101", "201111", "201121", "201131", "201141", "201151", "201161", "201171", "202011", "202012", "202021", "202022", "202031", "202041", "202042", "202051", "202052", "202061", "202071", "202081", "202082", "202091", "202092", "202101", "202102", "202111", "202121", "202131", "203011", "203012", "203013", "203014", "203015", "203021", "203022", "203031", "203032", "203041", "203051", "203052", "203061", "203062", "203071", "203072", "203073", "203081", "203082", "203083", "203084", "203091", "203092", "203093", "203101", "203102", "203103", "203111", "203112", "203113", "203121", "203122", "203123", "203131", "203141", "203151", "203161", "203171", "203181", "203191", "203201", "203202", "203203", "204011", "204012", "204013", "204014", "204021", "204022", "204023", "204024", "204031", "204032", "204033", "204034", "204041", "204042", "204043", "204044", "205011", "205012", "205013", "205014", "205015", "205021", "205022", "205031", "205032", "205041", "205051", "205052", "205061", "205062", "205071", "205081", "205082", "205083", "205091", "205101", "205102", "205103", "205111", "205112", "205113", "205121", "205122", "205123", "205131", "205141", "205151", "205161", "205171", "205181", "205191", "206011", "206012", "206013", "206014", "206021", "206022", "206023", "206024", "206031", "206032", "206041", "206042", "206043", "206051", "206052", "206053", "206054", "206061", "206062", "206063", "206064", "206065", "206066", "206071", "206072", "206073", "206081", "206091", "206101", "206111", "207011", "207021", "207031", "207041", "207051", "207061", "207071", "207091", "207101", "207111", "207121", "207131", "207141", "207151", "207161", "207162", "207163", "208011", "208012", "208021", "208022", "208023", "208024", "208031", "208032", "208033", "208034", "208041", "208042", "208051", "208061", "208071", "208081", "208082", "208091", "208092", "208093", "208094", "208101", "208102", "208103", "208104", "208111", "208112", "208121", "208131", "208141", "209011", "209012", "209013", "209014", "209015", "209021", "209031", "209041", "209042", "209043", "209051", "209061", "209071", "209081", "210011", "210012", "210021", "210022", "210031", "210032", "210033", "210041", "210042", "210043", "210051", "210052", "210061", "210062", "210071", "210072", "210073", "210074", "210081", "210082", "301011", "301021", "301031", "301032", "301041", "301042", "301043", "301044", "401011", "401021", "401031", "401041", "401051", "401061", "401071", "401081", "401091", "401101", "401102", "402011", "402012", "402013", "402021", "402022", "402023", "402024", "402031", "402032", "402033", "402041", "402042", "402043", "402044", "402045", "402051", "402052", "402053", "402054", "402055", "402061", "402062", "402063", "402071", "402072", "402073", "402081", "402082", "402083", "402091", "402101", "402111", "403011", "403012", "403013", "403021", "403022", "403023", "403031", "403041", "403042", "403043", "403044", "403051", "403052", "403061", "403062", "403071", "403072", "404011", "404012", "404013", "404021", "404022", "404023", "404031", "404032", "404033", "404041", "404042", "404043", "404051", "404052", "404053", "404061", "404062", "404063", "404071", "404072", "404073", "404081", "404082", "404083", "404091", "404092", "404093", "404101", "404111", "404112", "405011", "405012", "405013", "405014", "405015", "405021", "405031", "405041", "405051", "405052", "405061", "405062", "405071", "405072", "405081", "405091", "405101", "405111", "405121", "405131", "501011", "501021", "501031", "501041", "501051", "501061", "501071", "501081", "501091", "502011", "502021", "502022", "502023", "502024", "502031", "502032", "502033", "502041", "601011", "601012", "601021", "601031", "601041", "601051", "601061", "601071", "701011", "701012", "701021", "701022", "701031"];

/** The convert module contains functions to convert between Formal SignWriitng in ASCII (FSW) and SignWriting in Unicode (SWU) characters, along with other types of data.
 * [Characters set definitions](https://tools.ietf.org/id/draft-slevinski-formal-signwriting-09.html#name-characters)
 * @module convert
 */

/**
 * Function to convert an SWU structural marker to FSW equivalent
 * @function convert.swu2mark
 * @param {string} swuMark - character for SWU structural marker
 * @returns {string} FSW structural marker
 * @example
 * convert.swu2mark('𝠀')
 * 
 * return 'A'
 */
const swu2mark = swuMark => {
  return {
    '𝠀': 'A',
    '𝠁': 'B',
    '𝠂': 'L',
    '𝠃': 'M',
    '𝠄': 'R'
  }[swuMark];
};

/**
 * Function to convert an FSW structural marker to SWU equivalent
 * @function convert.mark2swu
 * @param {string} fswMark - character for FSW structural marker
 * @returns {string} SWU structural marker
 * @example
 * convert.mark2swu('A')
 * 
 * return '𝠀'
 */
const mark2swu = fswMark => {
  return {
    'A': '𝠀',
    'B': '𝠁',
    'L': '𝠂',
    'M': '𝠃',
    'R': '𝠄'
  }[fswMark];
};

/**
 * Function to convert an SWU number character to an integer
 * @function convert.swu2num
 * @param {string} swuNum - SWU number character
 * @returns {number} Integer value for number
 * @example
 * convert.swu2num('𝤆')
 * 
 * return 500
 */
const swu2num = swuNum => parseInt(swuNum.codePointAt(0)) - 0x1D80C + 250;

/**
 * Function to convert a number to an SWU number character
 * @function convert.num2swu
 * @param {number} num - Integer value for number
 * @returns {string} SWU number character
 * @example
 * convert.num2swu(500)
 * 
 * return '𝤆'
 */
const num2swu = num => String.fromCodePoint(0x1D80C + parseInt(num) - 250);

/**
 * Function to convert two SWU number characters to an array of x,y integers
 * @function convert.swu2coord
 * @param {string} swuCoord - Two SWU number character
 * @returns {number[]} Array of x,y integers
 * @example
 * convert.swu2coord('𝤆𝤆')
 * 
 * return [500, 500]
 */
const swu2coord = swuCoord => [swu2num(swuCoord.slice(0, 2)), swu2num(swuCoord.slice(2, 4))];

/**
 * Function to convert an array of x,y integers to two SWU number characters
 * @function convert.coord2swu
 * @param {number[]} coord - Array of x,y integers
 * @returns {string} Two SWU number character
 * @example
 * convert.coord2swu([500, 500])
 * 
 * return '𝤆𝤆'
 */
const coord2swu = coord => coord.map(num => num2swu(num)).join('');

/**
 * Function to convert an FSW coordinate string to an array of x,y integers
 * @function convert.fsw2coord
 * @param {string} fswCoord - An FSW coordinate string
 * @returns {number[]} Array of x,y integers
 * @example
 * convert.fsw2coord('500x500')
 * 
 * return [500, 500]
 */
const fsw2coord = fswCoord => fswCoord.split('x').map(num => parseInt(num));

/**
 * Function to convert an array of x,y integers to an FSW coordinate string
 * @function convert.coord2fsw
 * @param {number[]} coord - Array of x,y integers
 * @returns {string} An FSW coordinate string
 * @example
 * convert.coord2fsw([500, 500])
 * 
 * return '500x500'
 */
const coord2fsw = coord => coord.join('x');

/**
 * Function to convert an SWU symbol character to a code point on plane 4
 * @function convert.swu2code
 * @param {string} swuSym - SWU symbol character
 * @returns {number} Code point on plane 4
 * @example
 * convert.swu2code('񀀁')
 * 
 * return 0x40001
 */
const swu2code = swuSym => parseInt(swuSym.codePointAt(0));

/**
 * Function to convert a code point on plane 4 to an SWU symbol character
 * @function convert.code2swu
 * @param {number} code - Code point on plane 4
 * @returns {string} SWU symbol character
 * @example
 * convert.code2swu(0x40001)
 * 
 * return '񀀁'
 */
const code2swu = code => String.fromCodePoint(code);

/**
 * Function to convert an SWU symbol character to a 16-bit ID
 * @function convert.swu2id
 * @param {string} swuSym - SWU symbol character
 * @returns {number} 16-bit ID
 * @example
 * convert.swu2id('񀀁')
 * 
 * return 1
 */
const swu2id = swuSym => swu2code(swuSym) - 0x40000;

/**
 * Function to convert a 16-bit ID to an SWU symbol character
 * @function convert.id2swu
 * @param {number} id - 16-bit ID
 * @returns {string} SWU symbol character
 * @example
 * convert.id2swu(1)
 * 
 * return '񀀁'
 */
const id2swu = id => code2swu(id + 0x40000);

/**
 * Function to convert an FSW symbol key to a 16-bit ID
 * @function convert.key2id
 * @param {string} key - FSW symbol key
 * @returns {number} 16-bit ID
 * @example
 * convert.key2id('S10000')
 * 
 * return 1
 */
const key2id = key => key === "S00000" ? 0 : 1 + (parseInt(key.slice(1, 4), 16) - 256) * 96 + parseInt(key.slice(4, 5), 16) * 16 + parseInt(key.slice(5, 6), 16);

/**
 * Function to convert a 16-bit ID to an FSW symbol key
 * @function convert.id2key
 * @param {number} id - 16-bit ID
 * @returns {string} FSW symbol key
 * @example
 * convert.id2key(1)
 * 
 * return 'S10000'
 */
const id2key = id => {
  if (id === 0) {
    return "S00000";
  }
  const symcode = id - 1;
  const base = parseInt(symcode / 96);
  const fill = parseInt((symcode - base * 96) / 16);
  const rotation = parseInt(symcode - base * 96 - fill * 16);
  return 'S' + (base + 0x100).toString(16) + fill.toString(16) + rotation.toString(16);
};

/**
 * Function to convert an SWU symbol character to an FSW symbol key
 * @function convert.swu2key
 * @param {string} swuSym - SWU symbol character
 * @returns {string} FSW symbol key
 * @example
 * convert.swu2key('񀀁')
 * 
 * return 'S10000'
 */
const swu2key = swuSym => {
  if (swuSym === "񀀀") {
    return "S00000";
  }
  const symcode = swu2code(swuSym) - 0x40001;
  const base = parseInt(symcode / 96);
  const fill = parseInt((symcode - base * 96) / 16);
  const rotation = parseInt(symcode - base * 96 - fill * 16);
  return 'S' + (base + 0x100).toString(16) + fill.toString(16) + rotation.toString(16);
};

/**
 * Function to convert an FSW symbol key to an SWU symbol character
 * @function convert.key2swu
 * @param {string} key - FSW symbol key
 * @returns {string} SWU symbol character
 * @example
 * convert.key2swu('S10000')
 * 
 * return '񀀁'
 */
const key2swu = key => {
  if (key === "S00000") {
    return code2swu(0x40000);
  }
  return code2swu(0x40001 + (parseInt(key.slice(1, 4), 16) - 256) * 96 + parseInt(key.slice(4, 5), 16) * 16 + parseInt(key.slice(5, 6), 16));
};

/**
 * Function to convert SWU text to FSW text
 * @function convert.swu2fsw
 * @param {string} swuText - SWU text
 * @returns {string} FSW text
 * @example
 * convert.swu2fsw('𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭')
 * 
 * return 'AS10011S10019S2e704S2e748M525x535S2e748483x510S10011501x466S2e704510x500S10019476x475'
 */
const swu2fsw = swuText => {
  if (!swuText) return '';
  let fsw = swuText.replace(/𝠀/g, "A").replace(/𝠁/g, "B").replace(/𝠂/g, "L").replace(/𝠃/g, "M").replace(/𝠄/g, "R");
  const syms = fsw.match(new RegExp(re.nullorsymbol, 'g'));
  if (syms) {
    syms.forEach(function (sym) {
      fsw = fsw.replace(sym, swu2key(sym));
    });
  }
  const coords = fsw.match(new RegExp(re.coord, 'g'));
  if (coords) {
    coords.forEach(function (coord) {
      fsw = fsw.replace(coord, swu2coord(coord).join('x'));
    });
  }
  return fsw;
};

/**
 * Function to convert FSW text to SWU text
 * @function convert.fsw2swu
 * @param {string} fswText - FSW text
 * @returns {string} SWU text
 * @example
 * convert.fsw2swu('AS10011S10019S2e704S2e748M525x535S2e748483x510S10011501x466S2e704510x500S10019476x475')
 * 
 * return '𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭'
 */
const fsw2swu = fswText => {
  if (!fswText) return '';
  const prefixes = fswText.match(new RegExp(re$1.prefix, 'g'));
  if (prefixes) {
    prefixes.forEach(function (prefix) {
      fswText = fswText.replace(prefix, '𝠀' + prefix.slice(1).match(/.{6}/g).map(key => key2swu(key)).join(''));
    });
  }
  const boxes = fswText.match(new RegExp(re$1.box + re$1.coord, 'g'));
  if (boxes) {
    boxes.forEach(function (boxes) {
      fswText = fswText.replace(boxes, mark2swu(boxes.slice(0, 1)) + coord2swu(fsw2coord(boxes.slice(1, 8))));
    });
  }
  const spatials = fswText.match(new RegExp(re$1.spatial, 'g'));
  if (spatials) {
    spatials.forEach(function (spatial) {
      fswText = fswText.replace(spatial, key2swu(spatial.slice(0, 6)) + coord2swu(fsw2coord(spatial.slice(6, 13))));
    });
  }
  return fswText;
};

/**
 * Function to convert base or full symid Min to symid Max
 * @function convert.symidMax
 * @param {string} symidMin - Symbol ID minimized
 * @returns {string} Symbol ID maximized
 * @example
 * convert.symidMax('101011')
 * 
 * return '01-01-001-01'
 * @example
 * convert.symidMax('101011616')
 * 
 * return '01-01-001-01-06-16'
 */
const symidMax = symidMin => {
  if (!/^\d{6}(?:\d{3})?$/.test(symidMin)) {
    return '';
  }
  let max = `0${symidMin.charAt(0)}-${symidMin.charAt(1)}${symidMin.charAt(2)}-0${symidMin.charAt(3)}${symidMin.charAt(4)}-0${symidMin.charAt(5)}`;
  if (symidMin.length > 6) {
    max += `-0${symidMin.charAt(6)}-${symidMin.charAt(7)}${symidMin.charAt(8)}`;
  }
  return max;
};

/**
 * Function to convert base or full symid Max to symid Min
 * @function convert.symidMin
 * @param {string} symidMax - Symbol ID maximized
 * @returns {string} Symbol ID minimized
 * @example
 * convert.symidMin('01-01-001-01')
 * 
 * return '101011'
 * @example
 * convert.symidMin('01-01-001-01-06-16')
 * 
 * return '101011616'
 */
const symidMin = symidMax => {
  const matches = symidMax.match(/^0(\d)-(\d{2})-0(\d{2})-0(\d)(?:-0(\d)-(\d{2}))?$/);
  if (!matches) {
    return '';
  }
  if (matches[5]) {
    return matches[1] + matches[2] + matches[3] + matches[4] + matches[5] + matches[6];
  } else {
    return matches[1] + matches[2] + matches[3] + matches[4];
  }
};

/**
 * Function to convert base or full symid to key
 * @function convert.symid2key
 * @param {string} symid - Symbol ID
 * @returns {string} Symbol key
 * @example
 * convert.symid2key('01-01-001-01')
 * 
 * return 'S100'
 * @example
 * convert.symid2key('01-01-001-01-06-16')
 * 
 * return 'S1005f'
 */
const symid2key = symid => {
  const matches = symid.match(/^0(\d)-(\d{2})-0(\d{2})-0(\d)(?:-0(\d)-(\d{2}))?$/);
  if (!matches) {
    return '';
  }
  const symidMin = matches[1] + matches[2] + matches[3] + matches[4];
  const i = symidArr.indexOf(symidMin);
  if (i === -1) {
    return '';
  }
  if (matches[5]) {
    return 'S' + (256 + i).toString(16) + (parseInt(matches[5], 10) - 1) + (parseInt(matches[6], 10) - 1).toString(16);
  } else {
    return 'S' + (256 + i).toString(16);
  }
};

/**
 * Function to convert base or full key to symid
 * @function convert.key2symid
 * @param {string} key - Symbol key
 * @returns {string} Symbol ID
 * @example
 * convert.key2symid('S100')
 * 
 * return '01-01-001-01'
 * @example
 * convert.key2symid('S1005f')
 * 
 * return '01-01-001-01-06-16'
 */
const key2symid = key => {
  const matches = key.match(/^S([1-3][0-9a-f]{2})(?:([0-5])([0-9a-f]))?$/);
  if (!matches) {
    return '';
  }
  const i = parseInt(matches[1], 16) - 256;
  if (i >= symidArr.length) {
    return '';
  }
  if (matches[3]) {
    return symidMax(symidArr[i]) + '-0' + (1 + parseInt(matches[2])) + '-' + (parseInt(matches[3], 16) + 1).toString().padStart(2, '0');
  } else {
    return symidMax(symidArr[i]);
  }
};

exports.code2swu = code2swu;
exports.coord2fsw = coord2fsw;
exports.coord2swu = coord2swu;
exports.fsw2coord = fsw2coord;
exports.fsw2swu = fsw2swu;
exports.id2key = id2key;
exports.id2swu = id2swu;
exports.key2id = key2id;
exports.key2swu = key2swu;
exports.key2symid = key2symid;
exports.mark2swu = mark2swu;
exports.num2swu = num2swu;
exports.swu2code = swu2code;
exports.swu2coord = swu2coord;
exports.swu2fsw = swu2fsw;
exports.swu2id = swu2id;
exports.swu2key = swu2key;
exports.swu2mark = swu2mark;
exports.swu2num = swu2num;
exports.symid2key = symid2key;
exports.symidArr = symidArr;
exports.symidMax = symidMax;
exports.symidMin = symidMin;

/* support ongoing development */
/*   https://patreon.com/signwriting */
/*   https://donate.sutton-signwriting.io */
