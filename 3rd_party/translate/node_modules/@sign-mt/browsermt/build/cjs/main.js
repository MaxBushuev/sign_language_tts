"use strict";
var import_index = require("./index");
const statusEl = document.querySelector("#status");
const displayStatus = (status) => statusEl.innerText = status;
const langFromEl = document.querySelector("#lang-from");
const langToEl = document.querySelector("#lang-to");
const inputEl = document.querySelector("#input");
const outputEl = document.querySelector("#output");
const swapButtonEl = document.querySelector(".swap");
function _prepareTranslateOptions(paragraphs) {
  return new Array(paragraphs.length).fill({
    isQualityScores: true,
    isHtml: true
  });
}
function textToHTML(text) {
  const div = document.createElement("div");
  div.appendChild(document.createTextNode(text));
  return div.innerHTML;
}
async function main() {
  const comlinkWorker = (0, import_index.createBergamotWorker)("../../build/bundled/worker.js");
  await comlinkWorker.importBergamotWorker(
    "../../../artifacts/bergamot-translator-worker.js",
    "../../../artifacts/bergamot-translator-worker.wasm"
  );
  const MODEL_REGISTRY = "../../example/src/models/registry.json";
  const response = await fetch(MODEL_REGISTRY);
  const modelRegistry = await response.json();
  for (const [name, model] of Object.entries(modelRegistry)) {
    for (const file of Object.values(model)) {
      file.name = `../../example/src/models/${name}/${file.name}`;
    }
  }
  const translateCall = async () => {
    const text = inputEl.value;
    if (!text.trim().length)
      return;
    const paragraphs = text.split(/\n+/).map(textToHTML);
    const translateOptions = _prepareTranslateOptions(paragraphs);
    const lngFrom = langFromEl.value;
    const lngTo = langToEl.value;
    const results = await comlinkWorker.translate(
      lngFrom,
      lngTo,
      paragraphs,
      translateOptions
    );
    outputEl.innerHTML = "";
    for (const translatedHTML of results) {
      const translation = document.createElement("div");
      translation.classList.add("translation");
      translation.innerHTML = translatedHTML;
      addQualityClasses(translation);
      outputEl.appendChild(translation);
    }
  };
  const addQualityClasses = (root) => {
    root.querySelectorAll("[x-bergamot-sentence-score]").forEach((el) => {
      const score = el.getAttribute("x-bergamot-sentence-score") ?? "";
      el.classList.toggle("bad", parseFloat(score) < -0.6931);
    });
    root.querySelectorAll("[x-bergamot-word-score]").forEach((el) => {
      const score = el.getAttribute("x-bergamot-word-score") ?? "";
      el.classList.toggle("bad", parseFloat(score) < -0.6931);
    });
    root.querySelectorAll("[x-bergamot-sentence-score] > [x-bergamot-word-score]").forEach((el) => {
      const parent = el.parentNode;
      const sentenceScore = parseFloat(
        parent.getAttribute("x-bergamot-sentence-score") ?? ""
      );
      const wordScore = parseFloat(
        el.getAttribute("x-bergamot-word-score") ?? ""
      );
      el.setAttribute(
        "title",
        `Sentence: ${sentenceScore}  Word: ${wordScore}`
      );
    });
  };
  const loadModel = async () => {
    const lngFrom = langFromEl.value;
    const lngTo = langToEl.value;
    if (lngFrom !== lngTo) {
      displayStatus(`Installing model...`);
      console.log(`Loading model '${lngFrom}${lngTo}'`);
      displayStatus(
        await comlinkWorker.loadModel(lngFrom, lngTo, modelRegistry)
      );
      await translateCall();
    } else {
      outputEl.innerHTML = textToHTML(inputEl.value);
    }
  };
  langFromEl.addEventListener("change", loadModel);
  langToEl.addEventListener("change", loadModel);
  swapButtonEl.addEventListener("click", async () => {
    [langFromEl.value, langToEl.value] = [langToEl.value, langFromEl.value];
    inputEl.value = outputEl.innerText;
    await loadModel();
  });
  outputEl.addEventListener("mouseover", (e) => {
    const target = e.target;
    const parent = target.parentNode;
    const root = target.closest(".translation");
    const sentence = parent.hasAttribute("x-bergamot-sentence-index") ? parent.getAttribute("x-bergamot-sentence-index") : null;
    document.querySelectorAll("#output font[x-bergamot-sentence-index]").forEach((el) => {
      el.classList.toggle(
        "highlight-sentence",
        el.getAttribute("x-bergamot-sentence-index") === sentence && el.closest(".translation") === root
      );
    });
  });
  async function init() {
    const langs = Array.from(
      new Set(
        Object.keys(modelRegistry).reduce((acc, key) => {
          const middle = Math.round(key.length / 2);
          return acc.concat([
            key.substring(0, middle),
            key.substring(middle, key.length)
          ]);
        }, [])
      )
    );
    const langNames = new Intl.DisplayNames(void 0, { type: "language" });
    const langName = (lang) => langNames.of(lang) ?? lang;
    langs.sort((a, b) => langName(a).localeCompare(langName(b)));
    langs.forEach((code) => {
      const name = langName(code);
      langFromEl.innerHTML += `<option value="${code}">${name}</option>`;
      langToEl.innerHTML += `<option value="${code}">${name}</option>`;
    });
    langFromEl.value = "spoken";
    langToEl.value = "signed";
    await loadModel();
  }
  inputEl.addEventListener("keyup", translateCall);
  return init();
}
main().then(() => {
  console.log("ready");
}).catch((err) => console.error(err));
//# sourceMappingURL=main.js.map
