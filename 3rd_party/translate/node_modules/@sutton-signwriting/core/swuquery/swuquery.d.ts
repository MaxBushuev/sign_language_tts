export const __esModule: boolean;
/**
 * Function to compose SWU query string from object
 * @function swuquery.compose
 * @param {QueryObject} swuQueryObject - an object of query options
 * @returns {string} SWU query string
 * @example
 * swuquery.compose({
  *   query: true,
  *   prefix: {
  *     required: true,
  *     parts: [
  *       '񀀁',
  *       ['񀀁', '񆆑'],
  *       '񆇡'
  *     ]
  *   },
  *   signbox: [
  *     { symbol: '񆀁' },
  *     {
  *       range: ['񀀁', '񀇱'],
  *       coord: [500, 500]
  *     }
  *   ],
  *   variance: 5,
  *   style: true
  * })
  *
  * return 'QA񀀁R񀀁񆆑񆇡T񆀁R񀀁񀇱𝤆𝤆V5-'
  */
export function compose(swuQueryObject: QueryObject): string;
/**
 * Function that uses an SWU query string to match signs from multiple lines of text.
 * @function swuquery.lines
 * @param {string} query - an SWU query string
 * @param {string} text - multiple lines of text, each starting with an SWU sign
 * @returns {string[]} an array of lines of text, each starting with an SWU sign
 * @example
 * swuquery.lines('QA񀀒T',`𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭 line one
 * 𝠀񂇢񂇈񆙡񋎥񋎵𝠃𝤛𝤬񂇈𝤀𝣺񂇢𝤄𝣻񋎥𝤄𝤗񋎵𝤃𝣟񆙡𝣱𝣸 line two
 * 𝠀񅨑񀀙񆉁𝠃𝤙𝤞񀀙𝣷𝤀񅨑𝣼𝤀񆉁𝣳𝣮 line three`)
 *
 * return [
 *   '𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭 line one'
 * ]
 */
export function lines(query: string, text: string): string[];
/**
 * Function to parse SWU query string to object
 * @function swuquery.parse
 * @param {string} swuQueryString - an SWU query string
 * @returns {QueryObject} elements of an SWU query string
 * @example
 * swuquery.parse('QA񀀁R񀀁񆆑񆇡T񆀁R񀀁񀇱𝤆𝤆V5-')
 *
 * return {
 *   query: true,
 *   prefix: {
 *     required: true,
 *     parts: [
 *       '񀀁',
 *       ['񀀁', '񆆑'],
 *       '񆇡'
 *     ]
 *   },
 *   signbox: [
 *     { symbol: '񆀁' },
 *     {
 *       range: ['񀀁', '񀇱'],
 *       coord: [500, 500]
 *     }
 *   ],
 *   variance: 5,
 *   style: true
 * }
 */
declare function parse$1(swuQueryString: string): QueryObject;
/**
 * Function to transform a range of SWU characters to a regular expression
 * @function swuquery.range
 * @param {string} min - an SWU character
 * @param {string} max - an SWU character
 * @returns {string} a regular expression that matches a range of SWU characters
 * @example
 * swuquery.range('񀀁', '񀇡')
 *
 * return '\uD8C0[\uDC01-\uDDE1]'
 * @example
 * swuquery.range('𝣔', '𝤸')
 *
 * return '\uD836[\uDCD4-\uDD38]'
 */
export function range(min: string, max: string): string;
/**
 * Object of regular expressions for SWU query strings
 *
 * @alias swuquery.re
 * @type {object}
 * @property {string} null - the null symbol
 * @property {string} base - SWU symbol
 * @property {string} coord - SWU coordinate of X and Y number characters
 * @property {string} var - variance string for searching sign box
 * @property {string} symbol - SWU symbol character with ignore fill and rotation flags
 * @property {string} nullorsymbol - null or a symbol
 * @property {string} range - SWU range starting with 'R'
 * @property {string} item - SWU symbol or range query string
 * @property {string} list - several SWU symbols and SWU ranges as a logical OR for searching
 * @property {string} prefix - a sequential list of SWU symbol characters with nulls starting with SWU 'A' character
 * @property {string} signbox - several groups of SWU lists, each group having a coordinate
 * @property {string} full - a query string to search prefix in order and the signbox with variance
 */
declare let re$2: object;
/**
 * Function to transform an SWU query string to one or more regular expressions
 * @function swuquery.regex
 * @param {string} query - an SWU query string
 * @returns {string[]} an array of one or more regular expressions
 * @example
 * swuquery.regex('QA񀀒T')
 *
 * return [
 *   '(\uD836\uDC00\uD8C0\uDC12((?:(?:\uD8C0[\uDC01-\uDFFF])|(?:[\uD8C1-\uD8FC][\uDC00-\uDFFF])|(?:\uD8FD[\uDC00-\uDC80])))*)\uD836[\uDC01-\uDC04](?:\uD836[\uDC0C-\uDDFF]){2}((?:(?:\uD8C0[\uDC01-\uDFFF])|(?:[\uD8C1-\uD8FC][\uDC00-\uDFFF])|(?:\uD8FD[\uDC00-\uDC80]))(?:\uD836[\uDC0C-\uDDFF]){2})*'
 * ]
 */
export function regex(query: string): string[];
/**
 * Function that uses a query string to match signs from a string of text.
 * @function swuquery.results
 * @param {string} query - an SWU query string
 * @param {string} text - a string of text containing multiple signs
 * @returns {string[]} an array of SWU signs
 * @example
 * swuquery.results('QA񀀒T','𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭 𝠀񂇢񂇈񆙡񋎥񋎵𝠃𝤛𝤬񂇈𝤀𝣺񂇢𝤄𝣻񋎥𝤄𝤗񋎵𝤃𝣟񆙡𝣱𝣸 𝠀񅨑񀀙񆉁𝠃𝤙𝤞񀀙𝣷𝤀񅨑𝣼𝤀񆉁𝣳𝣮')
 *
 * return [
 *   '𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭'
 * ]
 */
export function results(query: string, text: string): string[];
/**
 * Function to convert an SWU sign to a query string
 *
 * For the flags parameter, use one or more of the following.
 * - A: exact symbol in temporal prefix
 * - a: general symbol in temporal prefix
 * - S: exact symbol in spatial signbox
 * - s: general symbol in spatial signbox
 * - L: spatial signbox symbol at location
 * @function swuquery.swu2query
 * @param {string} swuSign - SWU sign
 * @param {string} flags - flags for query string creation
 * @returns {string} SWU query string
 * @example
 * swuquery.swu2query('𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭', 'ASL')
 *
 * return 'QA񀀒񀀚񋚥񋛩T񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭'
 */
export function swu2query(swuSign: string, flags: string): string;
/**
 * Function to transform an SWU symbol with fill and rotation flags to a regular expression
 * @function swuquery.symbolRanges
 * @param {string} symbolFR - an SWU character with optional flags of 'f' for any fill and 'r' for any rotation
 * @returns {string} a regular expression that matches one or more ranges of SWU symbols
 * @example <caption>Match an exact symbol</caption>
 * swuquery.symbolRanges('񀀁')
 *
 * return '\uD8C0\uDC01');
 * @example <caption>Match a symbol with any fill</caption>
 * swuquery.symbolRanges('񀀁f')
 *
 * return '(\uD8C0\uDC01|\uD8C0\uDC11|\uD8C0\uDC21|\uD8C0\uDC31|\uD8C0\uDC41|\uD8C0\uDC51)'
 * @example <caption>Match a symbol with any rotation</caption>
 * swuquery.symbolRanges('񀀁r')
 *
 * return '\uD8C0[\uDC01-\uDC10]'
 * @example <caption>Match a symbol with any fill or rotation</caption>
 * swuquery.symbolRanges('񀀁fr')
 *
 * return '\uD8C0[\uDC01-\uDC60]'
 */
export function symbolRanges(symbolFR: string): string;
export { parse$1 as parse, re$2 as re };
/**
 * Object of query elements with regular expression identification.
 */
type QueryObject = {
    /**
     * - required true for query object
     */
    query: boolean;
    /**
     * - an object for prefix elements
     */
    prefix?: {
        required: boolean;
        parts?: (string | string[] | (string | string[])[])[];
    };
    /**
     * - array of objects for symbols, ranges, and list of symbols or ranges, with optional coordinates
     */
    signbox?: (QuerySignboxSymbol | QuerySignboxRange | QuerySignboxOr)[];
    /**
     * - amount that x or y coordinates can vary and find a match, defaults to 20
     */
    variance?: number;
    /**
     * - boolean value for including style string in matches
     */
    style?: boolean;
};
type QuerySignboxSymbol = {
    /**
     * - a symbol
     */
    symbol: string;
    /**
     * - an optional coordinate
     */
    coord?: number[];
};
type QuerySignboxRange = {
    /**
     * - an array of two symbols
     */
    range: string[];
    /**
     * - an optional coordinate
     */
    coord?: number[];
};
type QuerySignboxOr = {
    /**
     * - an array of symbol strings and range arrays
     */
    or: (string | string[])[];
    /**
     * - an optional coordinate
     */
    coord?: number[];
};
type ColumnOptions = {
    /**
     * - the height of the columns
     */
    height?: number;
    /**
     * - the widths of the columns
     */
    width?: number;
    /**
     * - the lane offset for left and right lanes
     */
    offset?: number;
    /**
     * - amount of padding before and after signs as well as at top, left, and right of columns
     */
    pad?: number;
    /**
     * - amount of space at bottom of column that is not available
     */
    margin?: number;
    /**
     * - enables variable width columns
     */
    dynamic?: boolean;
    /**
     * - background color for columns
     */
    background?: string;
    /**
     * - an object of style options
     */
    style?: StyleObject;
    /**
     * - an object of punctuation options
     */
    punctuation?: {
        spacing?: boolean;
        pad?: number;
        pull?: boolean;
    };
};
type ColumnData = ColumnSegment[];
type ColumnSegment = {
    /**
     * - the x position in the column
     */
    x: number;
    /**
     * - the y position in the column
     */
    y: number;
    /**
     * - the min x value within the segment
     */
    minX: number;
    /**
     * - the min y value within the segment
     */
    minY: number;
    /**
     * - the width of the text segment
     */
    width: number;
    /**
     * - the height of the text segment
     */
    height: number;
    /**
     * - Left as -1, Middle as 0, Right as 1
     */
    lane: number;
    /**
     * - the padding of the text segment affects colored background
     */
    padding: number;
    /**
     * - "sign" or "symbol"
     */
    segment: string;
    /**
     * - the text of the sign or symbol with optional style string
     */
    text: string;
    /**
     * - the zoom size of the segment
     */
    zoom: number;
};
type SegmentInfo = {
    /**
     * - the min x value within the segment
     */
    minX: number;
    /**
     * - the min y value within the segment
     */
    minY: number;
    /**
     * - the width of the text segment
     */
    width: number;
    /**
     * - the height of the text segment
     */
    height: number;
    /**
     * - Left as -1, Middle as 0, Right as 1
     */
    lane: number;
    /**
     * - the padding of the text segment affects colored background
     */
    padding: number;
    /**
     * - "sign" or "symbol"
     */
    segment: string;
    /**
     * - the zoom size of the segment
     */
    zoom: number;
};
/**
 * The elements of a style string
 */
type StyleObject = {
    /**
     * - boolean to use standardized colors for symbol groups
     */
    colorize?: boolean;
    /**
     * - integer value for padding around symbol or sign
     */
    padding?: number;
    /**
     * - css name or hex color for background
     */
    background?: string;
    /**
     * - array for css name or hex color for line and optional fill
     */
    detail?: string[];
    /**
     * - decimal value for zoom level
     */
    zoom?: number;
    /**
     * - custom colors for individual symbols
     */
    detailsym?: {
        index: number;
        detail: string[];
    };
    /**
     * - list of class names separated with spaces used for SVG
     */
    classes?: string;
    /**
     * - id name used for SVG
     */
    id?: string;
};
/**
 * The elements of a symbol string
 */
type SymbolObject = {
    /**
     * - symbol identifier
     */
    symbol?: string;
    /**
     * - x,y coordinate
     */
    coord?: number[];
    /**
     * - style string
     */
    style?: string;
};
/**
 * The elements of a sign string
 */
type SignObject = {
    /**
     * - array of symbols
     */
    sequence?: string[];
    /**
     * - signbox marker or lane
     */
    box?: string;
    /**
     * - preprocessed x,y coordinate
     */
    max?: number[];
    /**
     * - array of symbols with coordinates
     */
    spatials?: {
        symbol: string;
        coord: number[];
    }[];
    /**
     * - style string
     */
    style?: string;
};
type TokenizerObject = {
    /**
     * - Index to string mapping
     */
    i2s: any;
    /**
     * - String to index mapping
     */
    s2i: any;
    /**
     * - Total number of tokens
     */
    length: number;
    /**
     * - Returns array of all tokens
     */
    vocab: Function;
    /**
     * - Encodes a string of SignWriting to token indices
     */
    encode: Function;
    /**
     * - Decodes token indices to a string of SignWriting
     */
    decode: Function;
    /**
     * - Encodes an array of token strings to token indices
     */
    encodeTokens: Function;
    /**
     * - Decodes an array of token indices to token strings
     */
    decodeTokens: Function;
};
