{
  "version": 3,
  "sources": ["../../src/worker.ts"],
  "sourcesContent": ["/// <reference lib=\"webworker\" />\n\nimport { IncomingMessage } from \"http\";\n\nimport { isNode } from \"browser-or-node\";\nimport * as comlink from \"comlink\";\nimport { FileInfo, ModelRegistry, TranslationOptions } from \"./index\";\n\ncomlink.expose({ importBergamotWorker, loadModel, translate });\n\nconst timing: Record<string, number> = { workerStart: Date.now() };\n\nconst FILE_INFO: FileInfo[] = [\n  { type: \"model\", alignment: 256 },\n  { type: \"lex\", alignment: 64 },\n  { type: \"vocab\", alignment: 64 },\n  { type: \"qualityModel\", alignment: 64 },\n];\n\nfunction log(...args: any[]) {\n  console.debug(...args);\n}\n\nfunction logTime(timingKey: string, ...args: any[]) {\n  const time = (Date.now() - timing[timingKey]) / 1000;\n  log(...args, `${time} secs`);\n}\n\ninterface TranslationServiceConfig {\n  cacheSize: number;\n}\n\ninterface TranslationService {\n  new (config: TranslationServiceConfig): TranslationService;\n\n  translateViaPivoting: (\n    translationModelSrcToPivot: any,\n    translationModelPivotToTarget: any,\n    vectorSourceText: any,\n    vectorResponseOptions: any\n  ) => any;\n\n  translate: (\n    translationModel: any,\n    vectorSourceText: any,\n    vectorResponseOptions: any\n  ) => ResponseVector;\n}\n\nlet translationService: TranslationService;\n\nlet runtimeInitializedPromiseResolve: CallableFunction;\nconst runtimeInitializedPromise = new Promise(\n  (resolve) => (runtimeInitializedPromiseResolve = resolve)\n);\n\n// bergamot-translator-worker.js expects a \"Module\" object to be available\nlet workerWasmFilePath: string;\n\n(globalThis as any).Module = {\n  preRun: [\n    () => {\n      logTime(\"workerStart\", \"Time until Module.preRun\");\n      timing.moduleLoadStart = Date.now();\n    },\n  ],\n\n  locateFile: () => {\n    return workerWasmFilePath;\n  },\n\n  onRuntimeInitialized: async () => {\n    logTime(\n      \"moduleLoadStart\",\n      \"Wasm Runtime initialized Successfully (preRun -> onRuntimeInitialized)\"\n    );\n    runtimeInitializedPromiseResolve();\n  },\n} as any;\n\nasync function importBergamotWorker(\n  jsFilePath: string,\n  wasmFilePath: string | Buffer\n) {\n  if (typeof wasmFilePath === \"string\") {\n    workerWasmFilePath = wasmFilePath;\n  } else {\n    (globalThis as any).Module.wasmBinary = wasmFilePath;\n  }\n\n  if (isNode) {\n    const fs = require(\"fs\");\n    const code = fs.readFileSync(jsFilePath, \"utf-8\");\n    const vm = require(\"vm\");\n    vm.runInThisContext(code);\n  } else {\n    importScripts(jsFilePath);\n  }\n  await runtimeInitializedPromise;\n}\n\nasync function loadModel(\n  from: string,\n  to: string,\n  modelRegistry: ModelRegistry\n) {\n  timing.loadModelStart = Date.now();\n\n  try {\n    await constructTranslationService();\n    await constructTranslationModel(from, to, modelRegistry);\n    logTime(\"loadModelStart\", `Model '${from}-${to}' successfully constructed`);\n    return \"Model successfully loaded\";\n  } catch (error: any) {\n    console.error(error);\n    log(`Model '${from}${to}' construction failed:`, error.message);\n    return \"Model loading failed\";\n  }\n}\n\nfunction translate(\n  from: string,\n  to: string,\n  sentences: string[],\n  options: TranslationOptions[]\n) {\n  timing.translateStart = Date.now();\n\n  const wordCount = sentences.reduce(\n    (acc, sentence) => acc + _wordsCount(sentence),\n    0\n  );\n  let result;\n  try {\n    log(`Blocks to translate: ${sentences.length}`);\n    result = _translate(from, to, sentences, options);\n    const secs = (Date.now() - timing.translateStart) / 1000;\n    log(\n      `Speed: ${Math.round(\n        wordCount / secs\n      )} WPS (${wordCount} words in ${secs} secs)`\n    );\n  } catch (error: any) {\n    log(`Error:`, error.message);\n  }\n  return result;\n}\n\n// All variables specific to translation service\n\n// A map of language-pair to TranslationModel object\nconst languagePairToTranslationModels = new Map();\n\nconst PIVOT_LANGUAGE = \"en\";\n\nonmessage = async function (e) {\n  const command = e.data[0];\n  log(`Message '${command}' received from main script`);\n  if (command === \"translate\") {\n    const from = e.data[1];\n    const to = e.data[2];\n    const input = e.data[3];\n    const translateOptions = e.data[4];\n    const result = translate(from, to, input, translateOptions);\n    console.warn(result);\n    log(`'${command}' command done, Posting message back to main script`);\n    postMessage([`${command}_reply`, result]);\n  }\n};\n\n// Instantiates the Translation Service\nconst constructTranslationService = async () => {\n  if (!translationService) {\n    const config: TranslationServiceConfig = { cacheSize: 20000 };\n    log(`Creating Translation Service with config`, config);\n    translationService = new (globalThis as any).Module.BlockingService(config);\n    log(`Translation Service created successfully`);\n  }\n};\n\n// Constructs translation model(s) for the source and target language pair (using\n// pivoting if required).\nconst constructTranslationModel = async (\n  from: string,\n  to: string,\n  modelRegistry: ModelRegistry\n) => {\n  // Delete all previously constructed translation models and clear the map\n  languagePairToTranslationModels.forEach((value, key) => {\n    log(`Destructing model '${key}'`);\n    value.delete();\n  });\n  languagePairToTranslationModels.clear();\n\n  if (_isPivotingRequired(from, to)) {\n    // Pivoting requires 2 translation models\n    const languagePairSrcToPivot = _getLanguagePair(from, PIVOT_LANGUAGE);\n    const languagePairPivotToTarget = _getLanguagePair(PIVOT_LANGUAGE, to);\n    await Promise.all([\n      _constructTranslationModelHelper(languagePairSrcToPivot, modelRegistry),\n      _constructTranslationModelHelper(\n        languagePairPivotToTarget,\n        modelRegistry\n      ),\n    ]);\n  } else {\n    // Non-pivoting case requires only 1 translation model\n    await _constructTranslationModelHelper(\n      _getLanguagePair(from, to),\n      modelRegistry\n    );\n  }\n};\n\n// Translates text from source language to target language (via pivoting if necessary).\nconst _translate = (\n  from: string,\n  to: string,\n  input: string[],\n  translateOptions: TranslationOptions[]\n) => {\n  let vectorResponseOptions, vectorSourceText, vectorResponse;\n  try {\n    // Prepare the arguments (vectorResponseOptions and vectorSourceText (vector<string>)) of Translation API and call it.\n    // Result is a vector<Response> where each of its item corresponds to one item of vectorSourceText in the same order.\n    vectorResponseOptions = _prepareResponseOptions(translateOptions);\n    vectorSourceText = _prepareSourceText(input);\n\n    if (_isPivotingRequired(from, to)) {\n      // Translate via pivoting\n      const translationModelSrcToPivot = _getLoadedTranslationModel(\n        from,\n        PIVOT_LANGUAGE\n      );\n      const translationModelPivotToTarget = _getLoadedTranslationModel(\n        PIVOT_LANGUAGE,\n        to\n      );\n      vectorResponse = translationService.translateViaPivoting(\n        translationModelSrcToPivot,\n        translationModelPivotToTarget,\n        vectorSourceText,\n        vectorResponseOptions\n      );\n    } else {\n      // Translate without pivoting\n      const translationModel = _getLoadedTranslationModel(from, to);\n      vectorResponse = translationService.translate(\n        translationModel,\n        vectorSourceText,\n        vectorResponseOptions\n      );\n    }\n\n    // Parse all relevant information from vectorResponse\n    const listTranslatedText = _parseTranslatedText(vectorResponse);\n    const listSourceText = _parseSourceText(vectorResponse);\n    const listTranslatedTextSentences =\n      _parseTranslatedTextSentences(vectorResponse);\n    const listSourceTextSentences = _parseSourceTextSentences(vectorResponse);\n\n    log(`Source text: ${listSourceText}`);\n    log(`Translated text: ${listTranslatedText}`);\n    log(`Translated sentences: ${JSON.stringify(listTranslatedTextSentences)}`);\n    log(`Source sentences: ${JSON.stringify(listSourceTextSentences)}`);\n\n    return listTranslatedText;\n  } finally {\n    // Necessary clean up\n    if (vectorSourceText != null) vectorSourceText.delete();\n    if (vectorResponseOptions != null) vectorResponseOptions.delete();\n    if (vectorResponse != null) vectorResponse.delete();\n  }\n};\n\nconst _downloadAsArrayBufferNode = async (\n  url: string\n): Promise<ArrayBuffer> => {\n  const protocol = url.split(\"://\")[0];\n  const https = require(protocol);\n  return new Promise((resolve, reject) => {\n    const req = https.get(url, (res: IncomingMessage) => {\n      if (res.statusCode !== 200) {\n        reject(new Error(`Status code ${res.statusCode}`));\n        return;\n      }\n      const chunks: Buffer[] = [];\n      res.on(\"error\", (error: Error) => {\n        console.error(\"Error in fetching\", error);\n        reject(error);\n      });\n      res.on(\"data\", (chunk) => {\n        if (res.statusCode !== 200) {\n          reject(\"data: Status code is not 200\");\n        }\n        chunks.push(chunk);\n      });\n      res.on(\"end\", async () => {\n        if (res.statusCode !== 200) {\n          reject(\"end: Status code is not 200\");\n        }\n        const { Blob } = require(\"buffer\");\n        const data = new Blob(chunks);\n        try {\n          const buffer = await data.arrayBuffer();\n          resolve(buffer);\n        } catch (error) {\n          reject(error);\n        }\n      });\n    });\n\n    req.on(\"error\", function (e: any) {\n      // For some reason, firebase storage returns ECONNRESET while returning the right data\n      if (e.code !== \"ECONNRESET\") {\n        reject(e);\n      }\n    });\n    req.on(\"timeout\", function (e: any) {\n      console.error(`timeout: problem with request: ${e.message}`);\n      reject(e);\n    });\n    req.on(\"uncaughtException\", function (e: any) {\n      console.error(`uncaughtException: problem with request: ${e.message}`);\n      reject(e);\n    });\n  });\n};\n\n// Downloads file from a url and returns the array buffer\nconst _downloadAsArrayBuffer = async (url: string): Promise<ArrayBuffer> => {\n  if (isNode) {\n    return _downloadAsArrayBufferNode(url);\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw Error(\n      `Downloading ${url} failed: HTTP ${response.status} - ${response.statusText}`\n    );\n  }\n  return response.arrayBuffer();\n};\n\n// Constructs and initializes the AlignedMemory from the array buffer and alignment size\nconst _prepareAlignedMemoryFromBuffer = async (\n  buffer: ArrayBuffer,\n  alignmentSize: number\n) => {\n  const byteArray = new Int8Array(buffer);\n  const alignedMemory = new (globalThis as any).Module.AlignedMemory(\n    byteArray.byteLength,\n    alignmentSize\n  );\n  const alignedByteArrayView = alignedMemory.getByteArrayView();\n  alignedByteArrayView.set(byteArray);\n  return alignedMemory;\n};\n\nasync function prepareAlignedMemory(\n  file: FileInfo,\n  languagePair: string,\n  modelRegistry: ModelRegistry\n) {\n  const fileName = modelRegistry[languagePair][file.type].name;\n  const buffer = await _downloadAsArrayBuffer(fileName);\n  const alignedMemory = await _prepareAlignedMemoryFromBuffer(\n    buffer,\n    file.alignment\n  );\n  log(\n    `${\n      file.type\n    } aligned memory prepared. Size: ${alignedMemory.size()} bytes, alignment: ${\n      file.alignment\n    }`\n  );\n  return alignedMemory;\n}\n\nconst _constructTranslationModelHelper = async (\n  languagePair: string,\n  modelRegistry: ModelRegistry\n) => {\n  log(`Constructing translation model ${languagePair}`);\n\n  /*Set the Model Configuration as YAML formatted string.\n    For available configuration options, please check: https://marian-nmt.github.io/docs/cmd/marian-decoder/\n    Vocab files are re-used in both translation directions.\n    DO NOT CHANGE THE SPACES BETWEEN EACH ENTRY OF CONFIG\n  */\n  // Constraints:\n  // max-length-factor * max-length-break < mini-batch-words\n  const modelConfig = `beam-size: 12\nnormalize: 1.0\nword-penalty: 0\nmax-length-break: 512\nmini-batch-words: 8192\nworkspace: 512\nmax-length-factor: 12\nskip-cost: false\ncpu-threads: 0\nquiet: true\nquiet-translation: true\ngemm-precision: int8shiftAlphaAll\nalignment: soft\n`;\n\n  const alignedMemories = await Promise.all(\n    FILE_INFO.filter((file) => file.type in modelRegistry[languagePair]).map(\n      (file) => prepareAlignedMemory(file, languagePair, modelRegistry)\n    )\n  );\n\n  log(`Translation Model config: ${modelConfig}`);\n  log(\n    `Aligned memory sizes: Model:${alignedMemories[0].size()} Shortlist:${alignedMemories[1].size()} Vocab:${alignedMemories[2].size()}`\n  );\n  const alignedVocabMemoryList = new (\n    globalThis as any\n  ).Module.AlignedMemoryList();\n  alignedVocabMemoryList.push_back(alignedMemories[2]);\n  let translationModel;\n  if (alignedMemories.length === FILE_INFO.length) {\n    log(`QE:${alignedMemories[3].size()}`);\n    translationModel = new (globalThis as any).Module.TranslationModel(\n      modelConfig,\n      alignedMemories[0],\n      alignedMemories[1],\n      alignedVocabMemoryList,\n      alignedMemories[3]\n    );\n  } else {\n    translationModel = new (globalThis as any).Module.TranslationModel(\n      modelConfig,\n      alignedMemories[0],\n      alignedMemories[1],\n      alignedVocabMemoryList,\n      null\n    );\n  }\n  languagePairToTranslationModels.set(languagePair, translationModel);\n};\n\nconst _isPivotingRequired = (from: string, to: string) => {\n  return false;\n  // return from !== PIVOT_LANGUAGE && to !== PIVOT_LANGUAGE;\n};\n\nconst _getLanguagePair = (srcLang: string, tgtLang: string) => {\n  return `${srcLang}${tgtLang}`;\n};\n\nconst _getLoadedTranslationModel = (srcLang: string, tgtLang: string) => {\n  const languagePair = _getLanguagePair(srcLang, tgtLang);\n  if (!languagePairToTranslationModels.has(languagePair)) {\n    throw Error(`Translation model '${languagePair}' not loaded`);\n  }\n  return languagePairToTranslationModels.get(languagePair);\n};\n\nconst _parseTranslatedText = (vectorResponse: ResponseVector) => {\n  const result = [];\n  for (let i = 0; i < vectorResponse.size(); i++) {\n    const response = vectorResponse.get(i);\n    result.push(response.getTranslatedText());\n  }\n  return result;\n};\n\nconst _parseTranslatedTextSentences = (vectorResponse: ResponseVector) => {\n  const result = [];\n  for (let i = 0; i < vectorResponse.size(); i++) {\n    const response = vectorResponse.get(i);\n    result.push(_getTranslatedSentences(response));\n  }\n  return result;\n};\n\nconst _parseSourceText = (vectorResponse: ResponseVector) => {\n  const result = [];\n  for (let i = 0; i < vectorResponse.size(); i++) {\n    const response = vectorResponse.get(i);\n    result.push(response.getOriginalText());\n  }\n  return result;\n};\n\nconst _parseSourceTextSentences = (vectorResponse: ResponseVector) => {\n  const result = [];\n  for (let i = 0; i < vectorResponse.size(); i++) {\n    const response = vectorResponse.get(i);\n    result.push(_getSourceSentences(response));\n  }\n  return result;\n};\n\nconst _prepareResponseOptions = (translateOptions: TranslationOptions[]) => {\n  const vectorResponseOptions = new (\n    globalThis as any\n  ).Module.VectorResponseOptions();\n  translateOptions.forEach((translateOption) => {\n    vectorResponseOptions.push_back({\n      qualityScores: translateOption.isQualityScores,\n      alignment: true,\n      html: translateOption.isHtml,\n    });\n  });\n  if (vectorResponseOptions.size() == 0) {\n    vectorResponseOptions.delete();\n    throw Error(`No Translation Options provided`);\n  }\n  return vectorResponseOptions;\n};\n\nconst _prepareSourceText = (input: string[]) => {\n  const vectorSourceText = new (globalThis as any).Module.VectorString();\n  input.forEach((paragraph) => {\n    // prevent empty paragraph - it breaks the translation\n    if (paragraph.trim() === \"\") {\n      return;\n    }\n    vectorSourceText.push_back(paragraph.trim());\n  });\n  if (vectorSourceText.size() == 0) {\n    vectorSourceText.delete();\n    throw Error(`No text provided to translate`);\n  }\n  return vectorSourceText;\n};\n\ninterface Response {\n  getTranslatedText(): string;\n\n  getTranslatedSentence(index: number): { begin: number; end: number };\n\n  getSourceSentence(index: number): { begin: number; end: number };\n\n  size(): number;\n\n  getOriginalText(): string;\n}\n\ninterface ResponseVector {\n  size(): number;\n\n  get(index: number): Response;\n}\n\nconst _getTranslatedSentences = (response: Response) => {\n  const sentences = [];\n  const text = response.getTranslatedText();\n  for (\n    let sentenceIndex = 0;\n    sentenceIndex < response.size();\n    sentenceIndex++\n  ) {\n    const utf8SentenceByteRange = response.getTranslatedSentence(sentenceIndex);\n    sentences.push(_getSubString(text, utf8SentenceByteRange));\n  }\n  return sentences;\n};\n\nconst _getSourceSentences = (response: Response) => {\n  const sentences = [];\n  const text = response.getOriginalText();\n  for (\n    let sentenceIndex = 0;\n    sentenceIndex < response.size();\n    sentenceIndex++\n  ) {\n    const utf8SentenceByteRange = response.getSourceSentence(sentenceIndex);\n    sentences.push(_getSubString(text, utf8SentenceByteRange));\n  }\n  return sentences;\n};\n\n/*\n * Returns a substring of text (a string). The substring is represented by\n * byteRange (begin and end indices) within the utf-8 encoded version of the text.\n */\nconst _getSubString = (\n  text: string,\n  utf8ByteRange: { begin: number; end: number }\n) => {\n  const encoder = new TextEncoder(); // string to utf-8 converter\n  const decoder = new TextDecoder(); // utf-8 to string converter\n\n  const textUtf8ByteView = encoder.encode(text);\n  const substringUtf8ByteView = textUtf8ByteView.subarray(\n    utf8ByteRange.begin,\n    utf8ByteRange.end\n  );\n  return decoder.decode(substringUtf8ByteView);\n};\n\nfunction _wordsCount(sentence: string) {\n  return sentence\n    .trim()\n    .split(\" \")\n    .filter((word) => word.trim() !== \"\").length;\n}\n"],
  "mappings": "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",
  "names": []
}
