export const __esModule: boolean;
/**
 * Function to compose style string from object
 * @function style.compose
 * @param {StyleObject} styleObject - an object of style options
 * @returns {string} style string
 * @example
 * style.compose({
 *  'colorize': true,
 *  'padding': 10,
 *  'background': 'blue',
 *  'detail': ['red', 'Cyan'],
 *  'zoom': 1.1,
 *  'detailsym': [
 *    {
 *      'index': 1,
 *      'detail': ['#ff00ff']
 *    },
 *    {
 *      'index': 2,
 *      'detail': ['yellow', 'green']
 *    }
 *  ],
 *  'classes': 'primary blinking',
 *  'id': 'cursor'
 * })
 *
 * return '-CP10G_blue_D_red,Cyan_Z1.1-D01_ff00ff_D02_yellow,green_-primary blinking!cursor!'
 */
export function compose(styleObject: StyleObject): string;
/**
 * Function to merge style objects
 * @function style.merge
 * @param {StyleObject} style1 - a style object
 * @param {StyleObject} style2 - a style object
 * @returns {StyleObject} a style object
 * @example
 * style.merge({'colorize': true},{zoom:2})
 *
 * return {
 *  'colorize': true,
 *  'zoom': 2
 * }
 */
export function merge(style1: StyleObject, style2: StyleObject): StyleObject;
/**
 * Function to parse style string to object
 * @function style.parse
 * @param {string} styleString - a style string
 * @returns {StyleObject} elements of style string
 * @example
 * style.parse('-CP10G_blue_D_red,Cyan_')
 *
 * return {
 *  'colorize': true,
 *  'padding': 10,
 *  'background': 'blue',
 *  'detail': ['red', 'Cyan']
 * }
 */
export function parse(styleString: string): StyleObject;
/**
 * Object of regular expressions for style strings
 *
 * @alias style.re
 * @type {object}
 * @property {string} colorize - regular expression for colorize section
 * @property {string} colorhex - regular expression for color hex values with 3 or 6 characters
 * @property {string} colorname - regular expression for css color name
 * @property {string} padding - regular expression for padding section
 * @property {string} zoom - regular expression for zoom section
 * @property {string} classbase - regular expression for class name definition
 * @property {string} id - regular expression for id definition
 * @property {string} colorbase - regular expression for color hex or color name
 * @property {string} color - regular expression for single color entry
 * @property {string} colors - regular expression for double color entry
 * @property {string} background - regular expression for background section
 * @property {string} detail - regular expression for color details for line and optional fill
 * @property {string} detailsym - regular expression for color details for individual symbols
 * @property {string} classes - regular expression for one or more class names
 * @property {string} full - full regular expression for style string
 */
export let re: object;
/**
 * Function to convert rgb color to hex or "transparent" if below tolerance
 * @function style.rgb2hex
 * @param {string} rgb - an rgb color
 * @param {number} [tolerance=0] - max alpha for full transparency
 * @returns {string} a hex color or "transparent"
 * @example
 * style.rgb2hex("rgb(255,255,255)")
 * return "ffffff"
 *
 * style.rgb2hex("rgba(255,255,255,0.5)",0.5)
 * return "transparent"
 */
export function rgb2hex(rgb: string, tolerance?: number): string;
/**
 * Function to merge color with background based on alpha transparency
 * @function style.rgba2hex
 * @param {string} color - an rgba color
 * @param {string} background - an rgba background color
 * @returns {string} a hex color or "transparent"
 * @example
 * style.rgba2hex("rgba(255,255,255,0.5)","rgb(0,0,0)")
 *
 * return "7f7f7f"
 */
export function rgba2hex(color: string, background: string): string;
/**
 * Object of query elements with regular expression identification.
 */
type QueryObject = {
    /**
     * - required true for query object
     */
    query: boolean;
    /**
     * - an object for prefix elements
     */
    prefix?: {
        required: boolean;
        parts?: (string | string[] | (string | string[])[])[];
    };
    /**
     * - array of objects for symbols, ranges, and list of symbols or ranges, with optional coordinates
     */
    signbox?: (QuerySignboxSymbol | QuerySignboxRange | QuerySignboxOr)[];
    /**
     * - amount that x or y coordinates can vary and find a match, defaults to 20
     */
    variance?: number;
    /**
     * - boolean value for including style string in matches
     */
    style?: boolean;
};
type QuerySignboxSymbol = {
    /**
     * - a symbol
     */
    symbol: string;
    /**
     * - an optional coordinate
     */
    coord?: number[];
};
type QuerySignboxRange = {
    /**
     * - an array of two symbols
     */
    range: string[];
    /**
     * - an optional coordinate
     */
    coord?: number[];
};
type QuerySignboxOr = {
    /**
     * - an array of symbol strings and range arrays
     */
    or: (string | string[])[];
    /**
     * - an optional coordinate
     */
    coord?: number[];
};
type ColumnOptions = {
    /**
     * - the height of the columns
     */
    height?: number;
    /**
     * - the widths of the columns
     */
    width?: number;
    /**
     * - the lane offset for left and right lanes
     */
    offset?: number;
    /**
     * - amount of padding before and after signs as well as at top, left, and right of columns
     */
    pad?: number;
    /**
     * - amount of space at bottom of column that is not available
     */
    margin?: number;
    /**
     * - enables variable width columns
     */
    dynamic?: boolean;
    /**
     * - background color for columns
     */
    background?: string;
    /**
     * - an object of style options
     */
    style?: StyleObject;
    /**
     * - an object of punctuation options
     */
    punctuation?: {
        spacing?: boolean;
        pad?: number;
        pull?: boolean;
    };
};
type ColumnData = ColumnSegment[];
type ColumnSegment = {
    /**
     * - the x position in the column
     */
    x: number;
    /**
     * - the y position in the column
     */
    y: number;
    /**
     * - the min x value within the segment
     */
    minX: number;
    /**
     * - the min y value within the segment
     */
    minY: number;
    /**
     * - the width of the text segment
     */
    width: number;
    /**
     * - the height of the text segment
     */
    height: number;
    /**
     * - Left as -1, Middle as 0, Right as 1
     */
    lane: number;
    /**
     * - the padding of the text segment affects colored background
     */
    padding: number;
    /**
     * - "sign" or "symbol"
     */
    segment: string;
    /**
     * - the text of the sign or symbol with optional style string
     */
    text: string;
    /**
     * - the zoom size of the segment
     */
    zoom: number;
};
type SegmentInfo = {
    /**
     * - the min x value within the segment
     */
    minX: number;
    /**
     * - the min y value within the segment
     */
    minY: number;
    /**
     * - the width of the text segment
     */
    width: number;
    /**
     * - the height of the text segment
     */
    height: number;
    /**
     * - Left as -1, Middle as 0, Right as 1
     */
    lane: number;
    /**
     * - the padding of the text segment affects colored background
     */
    padding: number;
    /**
     * - "sign" or "symbol"
     */
    segment: string;
    /**
     * - the zoom size of the segment
     */
    zoom: number;
};
/**
 * The elements of a style string
 */
type StyleObject = {
    /**
     * - boolean to use standardized colors for symbol groups
     */
    colorize?: boolean;
    /**
     * - integer value for padding around symbol or sign
     */
    padding?: number;
    /**
     * - css name or hex color for background
     */
    background?: string;
    /**
     * - array for css name or hex color for line and optional fill
     */
    detail?: string[];
    /**
     * - decimal value for zoom level
     */
    zoom?: number;
    /**
     * - custom colors for individual symbols
     */
    detailsym?: {
        index: number;
        detail: string[];
    };
    /**
     * - list of class names separated with spaces used for SVG
     */
    classes?: string;
    /**
     * - id name used for SVG
     */
    id?: string;
};
/**
 * The elements of a symbol string
 */
type SymbolObject = {
    /**
     * - symbol identifier
     */
    symbol?: string;
    /**
     * - x,y coordinate
     */
    coord?: number[];
    /**
     * - style string
     */
    style?: string;
};
/**
 * The elements of a sign string
 */
type SignObject = {
    /**
     * - array of symbols
     */
    sequence?: string[];
    /**
     * - signbox marker or lane
     */
    box?: string;
    /**
     * - preprocessed x,y coordinate
     */
    max?: number[];
    /**
     * - array of symbols with coordinates
     */
    spatials?: {
        symbol: string;
        coord: number[];
    }[];
    /**
     * - style string
     */
    style?: string;
};
type TokenizerObject = {
    /**
     * - Index to string mapping
     */
    i2s: any;
    /**
     * - String to index mapping
     */
    s2i: any;
    /**
     * - Total number of tokens
     */
    length: number;
    /**
     * - Returns array of all tokens
     */
    vocab: Function;
    /**
     * - Encodes a string of SignWriting to token indices
     */
    encode: Function;
    /**
     * - Decodes token indices to a string of SignWriting
     */
    decode: Function;
    /**
     * - Encodes an array of token strings to token indices
     */
    encodeTokens: Function;
    /**
     * - Decodes an array of token indices to token strings
     */
    decodeTokens: Function;
};
