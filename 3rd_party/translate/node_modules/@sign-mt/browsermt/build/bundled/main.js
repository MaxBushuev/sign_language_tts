var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/comlink/dist/umd/comlink.js
var require_comlink = __commonJS({
  "node_modules/comlink/dist/umd/comlink.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.Comlink = {}));
    })(exports, function(exports2) {
      "use strict";
      const proxyMarker = Symbol("Comlink.proxy");
      const createEndpoint = Symbol("Comlink.endpoint");
      const releaseProxy = Symbol("Comlink.releaseProxy");
      const throwMarker = Symbol("Comlink.thrown");
      const isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
      const proxyTransferHandler = {
        canHandle: (val) => isObject(val) && val[proxyMarker],
        serialize(obj) {
          const { port1, port2 } = new MessageChannel();
          expose(obj, port1);
          return [port2, [port2]];
        },
        deserialize(port) {
          port.start();
          return wrap2(port);
        }
      };
      const throwTransferHandler = {
        canHandle: (value) => isObject(value) && throwMarker in value,
        serialize({ value }) {
          let serialized;
          if (value instanceof Error) {
            serialized = {
              isError: true,
              value: {
                message: value.message,
                name: value.name,
                stack: value.stack
              }
            };
          } else {
            serialized = { isError: false, value };
          }
          return [serialized, []];
        },
        deserialize(serialized) {
          if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
          }
          throw serialized.value;
        }
      };
      const transferHandlers = /* @__PURE__ */ new Map([
        ["proxy", proxyTransferHandler],
        ["throw", throwTransferHandler]
      ]);
      function expose(obj, ep = self) {
        ep.addEventListener("message", function callback(ev) {
          if (!ev || !ev.data) {
            return;
          }
          const { id, type, path } = Object.assign({ path: [] }, ev.data);
          const argumentList = (ev.data.argumentList || []).map(fromWireValue);
          let returnValue;
          try {
            const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
            const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
            switch (type) {
              case "GET":
                {
                  returnValue = rawValue;
                }
                break;
              case "SET":
                {
                  parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                  returnValue = true;
                }
                break;
              case "APPLY":
                {
                  returnValue = rawValue.apply(parent, argumentList);
                }
                break;
              case "CONSTRUCT":
                {
                  const value = new rawValue(...argumentList);
                  returnValue = proxy(value);
                }
                break;
              case "ENDPOINT":
                {
                  const { port1, port2 } = new MessageChannel();
                  expose(obj, port2);
                  returnValue = transfer(port1, [port1]);
                }
                break;
              case "RELEASE":
                {
                  returnValue = void 0;
                }
                break;
              default:
                return;
            }
          } catch (value) {
            returnValue = { value, [throwMarker]: 0 };
          }
          Promise.resolve(returnValue).catch((value) => {
            return { value, [throwMarker]: 0 };
          }).then((returnValue2) => {
            const [wireValue, transferables] = toWireValue(returnValue2);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
            if (type === "RELEASE") {
              ep.removeEventListener("message", callback);
              closeEndPoint(ep);
            }
          });
        });
        if (ep.start) {
          ep.start();
        }
      }
      function isMessagePort(endpoint) {
        return endpoint.constructor.name === "MessagePort";
      }
      function closeEndPoint(endpoint) {
        if (isMessagePort(endpoint))
          endpoint.close();
      }
      function wrap2(ep, target) {
        return createProxy(ep, [], target);
      }
      function throwIfProxyReleased(isReleased) {
        if (isReleased) {
          throw new Error("Proxy has been released and is not useable");
        }
      }
      function createProxy(ep, path = [], target = function() {
      }) {
        let isProxyReleased = false;
        const proxy2 = new Proxy(target, {
          get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
              return () => {
                return requestResponseMessage(ep, {
                  type: "RELEASE",
                  path: path.map((p) => p.toString())
                }).then(() => {
                  closeEndPoint(ep);
                  isProxyReleased = true;
                });
              };
            }
            if (prop === "then") {
              if (path.length === 0) {
                return { then: () => proxy2 };
              }
              const r = requestResponseMessage(ep, {
                type: "GET",
                path: path.map((p) => p.toString())
              }).then(fromWireValue);
              return r.then.bind(r);
            }
            return createProxy(ep, [...path, prop]);
          },
          set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, {
              type: "SET",
              path: [...path, prop].map((p) => p.toString()),
              value
            }, transferables).then(fromWireValue);
          },
          apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
              return requestResponseMessage(ep, {
                type: "ENDPOINT"
              }).then(fromWireValue);
            }
            if (last === "bind") {
              return createProxy(ep, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
              type: "APPLY",
              path: path.map((p) => p.toString()),
              argumentList
            }, transferables).then(fromWireValue);
          },
          construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
              type: "CONSTRUCT",
              path: path.map((p) => p.toString()),
              argumentList
            }, transferables).then(fromWireValue);
          }
        });
        return proxy2;
      }
      function myFlat(arr) {
        return Array.prototype.concat.apply([], arr);
      }
      function processArguments(argumentList) {
        const processed = argumentList.map(toWireValue);
        return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
      }
      const transferCache = /* @__PURE__ */ new WeakMap();
      function transfer(obj, transfers) {
        transferCache.set(obj, transfers);
        return obj;
      }
      function proxy(obj) {
        return Object.assign(obj, { [proxyMarker]: true });
      }
      function windowEndpoint(w, context = self, targetOrigin = "*") {
        return {
          postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
          addEventListener: context.addEventListener.bind(context),
          removeEventListener: context.removeEventListener.bind(context)
        };
      }
      function toWireValue(value) {
        for (const [name, handler] of transferHandlers) {
          if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
              {
                type: "HANDLER",
                name,
                value: serializedValue
              },
              transferables
            ];
          }
        }
        return [
          {
            type: "RAW",
            value
          },
          transferCache.get(value) || []
        ];
      }
      function fromWireValue(value) {
        switch (value.type) {
          case "HANDLER":
            return transferHandlers.get(value.name).deserialize(value.value);
          case "RAW":
            return value.value;
        }
      }
      function requestResponseMessage(ep, msg, transfers) {
        return new Promise((resolve) => {
          const id = generateUUID();
          ep.addEventListener("message", function l(ev) {
            if (!ev.data || !ev.data.id || ev.data.id !== id) {
              return;
            }
            ep.removeEventListener("message", l);
            resolve(ev.data);
          });
          if (ep.start) {
            ep.start();
          }
          ep.postMessage(Object.assign({ id }, msg), transfers);
        });
      }
      function generateUUID() {
        return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
      }
      exports2.createEndpoint = createEndpoint;
      exports2.expose = expose;
      exports2.proxy = proxy;
      exports2.proxyMarker = proxyMarker;
      exports2.releaseProxy = releaseProxy;
      exports2.transfer = transfer;
      exports2.transferHandlers = transferHandlers;
      exports2.windowEndpoint = windowEndpoint;
      exports2.wrap = wrap2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/web-worker/cjs/node.js
var require_node = __commonJS({
  "node_modules/web-worker/cjs/node.js"(exports, module) {
    var URL = __require("url");
    var VM = __require("vm");
    var threads = __require("worker_threads");
    var WORKER = Symbol.for("worker");
    var EVENTS = Symbol.for("events");
    var EventTarget = class {
      constructor() {
        Object.defineProperty(this, EVENTS, {
          value: /* @__PURE__ */ new Map()
        });
      }
      dispatchEvent(event) {
        event.target = event.currentTarget = this;
        if (this["on" + event.type]) {
          try {
            this["on" + event.type](event);
          } catch (err) {
            console.error(err);
          }
        }
        const list = this[EVENTS].get(event.type);
        if (list == null)
          return;
        list.forEach((handler) => {
          try {
            handler.call(this, event);
          } catch (err) {
            console.error(err);
          }
        });
      }
      addEventListener(type, fn) {
        let events = this[EVENTS].get(type);
        if (!events)
          this[EVENTS].set(type, events = []);
        events.push(fn);
      }
      removeEventListener(type, fn) {
        let events = this[EVENTS].get(type);
        if (events) {
          const index = events.indexOf(fn);
          if (index !== -1)
            events.splice(index, 1);
        }
      }
    };
    function Event(type, target) {
      this.type = type;
      this.timeStamp = Date.now();
      this.target = this.currentTarget = this.data = null;
    }
    module.exports = threads.isMainThread ? mainThread() : workerThread();
    var baseUrl = URL.pathToFileURL(process.cwd() + "/");
    function mainThread() {
      class Worker extends EventTarget {
        constructor(url, options) {
          super();
          const {
            name,
            type
          } = options || {};
          url += "";
          let mod;
          if (/^data:/.test(url)) {
            mod = url;
          } else {
            mod = URL.fileURLToPath(new URL.URL(url, baseUrl));
          }
          const worker = new threads.Worker(__filename, {
            workerData: {
              mod,
              name,
              type
            }
          });
          Object.defineProperty(this, WORKER, {
            value: worker
          });
          worker.on("message", (data) => {
            const event = new Event("message");
            event.data = data;
            this.dispatchEvent(event);
          });
          worker.on("error", (error) => {
            error.type = "error";
            this.dispatchEvent(error);
          });
          worker.on("exit", () => {
            this.dispatchEvent(new Event("close"));
          });
        }
        postMessage(data, transferList) {
          this[WORKER].postMessage(data, transferList);
        }
        terminate() {
          this[WORKER].terminate();
        }
      }
      Worker.prototype.onmessage = Worker.prototype.onerror = Worker.prototype.onclose = null;
      return Worker;
    }
    function workerThread() {
      let {
        mod,
        name,
        type
      } = threads.workerData;
      const self2 = global.self = global;
      let q = [];
      function flush() {
        const buffered = q;
        q = null;
        buffered.forEach((event) => {
          self2.dispatchEvent(event);
        });
      }
      threads.parentPort.on("message", (data) => {
        const event = new Event("message");
        event.data = data;
        if (q == null)
          self2.dispatchEvent(event);
        else
          q.push(event);
      });
      threads.parentPort.on("error", (err) => {
        err.type = "Error";
        self2.dispatchEvent(err);
      });
      class WorkerGlobalScope extends EventTarget {
        postMessage(data, transferList) {
          threads.parentPort.postMessage(data, transferList);
        }
        close() {
          process.exit();
        }
      }
      let proto = Object.getPrototypeOf(global);
      delete proto.constructor;
      Object.defineProperties(WorkerGlobalScope.prototype, proto);
      proto = Object.setPrototypeOf(global, new WorkerGlobalScope());
      ["postMessage", "addEventListener", "removeEventListener", "dispatchEvent"].forEach((fn) => {
        proto[fn] = proto[fn].bind(global);
      });
      global.name = name;
      const isDataUrl = /^data:/.test(mod);
      if (type === "module") {
        import(mod).catch((err) => {
          if (isDataUrl && err.message === "Not supported") {
            console.warn("Worker(): Importing data: URLs requires Node 12.10+. Falling back to classic worker.");
            return evaluateDataUrl(mod, name);
          }
          console.error(err);
        }).then(flush);
      } else {
        try {
          if (/^data:/.test(mod)) {
            evaluateDataUrl(mod, name);
          } else {
            __require(mod);
          }
        } catch (err) {
          console.error(err);
        }
        Promise.resolve().then(flush);
      }
    }
    function evaluateDataUrl(url, name) {
      const {
        data
      } = parseDataUrl(url);
      return VM.runInThisContext(data, {
        filename: "worker.<" + (name || "data:") + ">"
      });
    }
    function parseDataUrl(url) {
      let [m, type, encoding, data] = url.match(/^data: *([^;,]*)(?: *; *([^,]*))? *,(.*)$/) || [];
      if (!m)
        throw Error("Invalid Data URL.");
      if (encoding)
        switch (encoding.toLowerCase()) {
          case "base64":
            data = Buffer.from(data, "base64").toString();
            break;
          default:
            throw Error('Unknown Data URL encoding "' + encoding + '"');
        }
      return {
        type,
        data
      };
    }
  }
});

// src/index.ts
var comlink = __toESM(require_comlink());
function createBergamotWorker(path) {
  const workerClass = "Worker" in globalThis ? globalThis.Worker : require_node();
  const worker = new workerClass(path);
  const abortionError = new Promise((resolve, reject) => {
    worker.addEventListener("error", reject);
    worker.addEventListener("close", resolve);
  });
  return new Proxy(comlink.wrap(worker), {
    get(target, prop, receiver) {
      if (prop === "terminate") {
        return () => {
          worker.terminate();
        };
      }
      const targetProp = Reflect.get(target, prop, receiver);
      if (typeof targetProp === "function") {
        return (...args) => {
          return Promise.race([targetProp(...args), abortionError]);
        };
      }
      return targetProp;
    }
  });
}

// src/main.ts
var statusEl = document.querySelector("#status");
var displayStatus = (status) => statusEl.innerText = status;
var langFromEl = document.querySelector("#lang-from");
var langToEl = document.querySelector("#lang-to");
var inputEl = document.querySelector("#input");
var outputEl = document.querySelector("#output");
var swapButtonEl = document.querySelector(".swap");
function _prepareTranslateOptions(paragraphs) {
  return new Array(paragraphs.length).fill({
    isQualityScores: true,
    isHtml: true
  });
}
function textToHTML(text) {
  const div = document.createElement("div");
  div.appendChild(document.createTextNode(text));
  return div.innerHTML;
}
async function main() {
  const comlinkWorker = createBergamotWorker("../../build/bundled/worker.js");
  await comlinkWorker.importBergamotWorker(
    "../../../artifacts/bergamot-translator-worker.js",
    "../../../artifacts/bergamot-translator-worker.wasm"
  );
  const MODEL_REGISTRY = "../../example/src/models/registry.json";
  const response = await fetch(MODEL_REGISTRY);
  const modelRegistry = await response.json();
  for (const [name, model] of Object.entries(modelRegistry)) {
    for (const file of Object.values(model)) {
      file.name = `../../example/src/models/${name}/${file.name}`;
    }
  }
  const translateCall = async () => {
    const text = inputEl.value;
    if (!text.trim().length)
      return;
    const paragraphs = text.split(/\n+/).map(textToHTML);
    const translateOptions = _prepareTranslateOptions(paragraphs);
    const lngFrom = langFromEl.value;
    const lngTo = langToEl.value;
    const results = await comlinkWorker.translate(
      lngFrom,
      lngTo,
      paragraphs,
      translateOptions
    );
    outputEl.innerHTML = "";
    for (const translatedHTML of results) {
      const translation = document.createElement("div");
      translation.classList.add("translation");
      translation.innerHTML = translatedHTML;
      addQualityClasses(translation);
      outputEl.appendChild(translation);
    }
  };
  const addQualityClasses = (root) => {
    root.querySelectorAll("[x-bergamot-sentence-score]").forEach((el) => {
      const score = el.getAttribute("x-bergamot-sentence-score") ?? "";
      el.classList.toggle("bad", parseFloat(score) < -0.6931);
    });
    root.querySelectorAll("[x-bergamot-word-score]").forEach((el) => {
      const score = el.getAttribute("x-bergamot-word-score") ?? "";
      el.classList.toggle("bad", parseFloat(score) < -0.6931);
    });
    root.querySelectorAll("[x-bergamot-sentence-score] > [x-bergamot-word-score]").forEach((el) => {
      const parent = el.parentNode;
      const sentenceScore = parseFloat(
        parent.getAttribute("x-bergamot-sentence-score") ?? ""
      );
      const wordScore = parseFloat(
        el.getAttribute("x-bergamot-word-score") ?? ""
      );
      el.setAttribute(
        "title",
        `Sentence: ${sentenceScore}  Word: ${wordScore}`
      );
    });
  };
  const loadModel = async () => {
    const lngFrom = langFromEl.value;
    const lngTo = langToEl.value;
    if (lngFrom !== lngTo) {
      displayStatus(`Installing model...`);
      console.log(`Loading model '${lngFrom}${lngTo}'`);
      displayStatus(
        await comlinkWorker.loadModel(lngFrom, lngTo, modelRegistry)
      );
      await translateCall();
    } else {
      outputEl.innerHTML = textToHTML(inputEl.value);
    }
  };
  langFromEl.addEventListener("change", loadModel);
  langToEl.addEventListener("change", loadModel);
  swapButtonEl.addEventListener("click", async () => {
    [langFromEl.value, langToEl.value] = [langToEl.value, langFromEl.value];
    inputEl.value = outputEl.innerText;
    await loadModel();
  });
  outputEl.addEventListener("mouseover", (e) => {
    const target = e.target;
    const parent = target.parentNode;
    const root = target.closest(".translation");
    const sentence = parent.hasAttribute("x-bergamot-sentence-index") ? parent.getAttribute("x-bergamot-sentence-index") : null;
    document.querySelectorAll("#output font[x-bergamot-sentence-index]").forEach((el) => {
      el.classList.toggle(
        "highlight-sentence",
        el.getAttribute("x-bergamot-sentence-index") === sentence && el.closest(".translation") === root
      );
    });
  });
  async function init() {
    const langs = Array.from(
      new Set(
        Object.keys(modelRegistry).reduce((acc, key) => {
          const middle = Math.round(key.length / 2);
          return acc.concat([
            key.substring(0, middle),
            key.substring(middle, key.length)
          ]);
        }, [])
      )
    );
    const langNames = new Intl.DisplayNames(void 0, { type: "language" });
    const langName = (lang) => langNames.of(lang) ?? lang;
    langs.sort((a, b) => langName(a).localeCompare(langName(b)));
    langs.forEach((code) => {
      const name = langName(code);
      langFromEl.innerHTML += `<option value="${code}">${name}</option>`;
      langToEl.innerHTML += `<option value="${code}">${name}</option>`;
    });
    langFromEl.value = "spoken";
    langToEl.value = "signed";
    await loadModel();
  }
  inputEl.addEventListener("keyup", translateCall);
  return init();
}
main().then(() => {
  console.log("ready");
}).catch((err) => console.error(err));
//# sourceMappingURL=main.js.map
