{
  "version": 3,
  "sources": ["../../node_modules/browser-or-node/lib/index.js", "../../node_modules/comlink/src/comlink.ts", "../../src/worker.ts"],
  "sourcesContent": ["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\nvar isNode = typeof process !== \"undefined\" && process.versions != null && process.versions.node != null;\n\nvar isWebWorker = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === \"object\" && self.constructor && self.constructor.name === \"DedicatedWorkerGlobalScope\";\n\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\nvar isJsDom = typeof window !== \"undefined\" && window.name === \"nodejs\" || typeof navigator !== \"undefined\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\n\nvar isDeno = typeof Deno !== \"undefined\" && typeof Deno.core !== \"undefined\";\n\nexports.isBrowser = isBrowser;\nexports.isWebWorker = isWebWorker;\nexports.isNode = isNode;\nexports.isJsDom = isJsDom;\nexports.isDeno = isDeno;", "/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \u00AF\\_(\u30C4)_/\u00AF\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn\u2019t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n", "/// <reference lib=\"webworker\" />\n\nimport { IncomingMessage } from \"http\";\n\nimport { isNode } from \"browser-or-node\";\nimport * as comlink from \"comlink\";\nimport { FileInfo, ModelRegistry, TranslationOptions } from \"./index\";\n\ncomlink.expose({ importBergamotWorker, loadModel, translate });\n\nconst timing: Record<string, number> = { workerStart: Date.now() };\n\nconst FILE_INFO: FileInfo[] = [\n  { type: \"model\", alignment: 256 },\n  { type: \"lex\", alignment: 64 },\n  { type: \"vocab\", alignment: 64 },\n  { type: \"qualityModel\", alignment: 64 },\n];\n\nfunction log(...args: any[]) {\n  console.debug(...args);\n}\n\nfunction logTime(timingKey: string, ...args: any[]) {\n  const time = (Date.now() - timing[timingKey]) / 1000;\n  log(...args, `${time} secs`);\n}\n\ninterface TranslationServiceConfig {\n  cacheSize: number;\n}\n\ninterface TranslationService {\n  new (config: TranslationServiceConfig): TranslationService;\n\n  translateViaPivoting: (\n    translationModelSrcToPivot: any,\n    translationModelPivotToTarget: any,\n    vectorSourceText: any,\n    vectorResponseOptions: any\n  ) => any;\n\n  translate: (\n    translationModel: any,\n    vectorSourceText: any,\n    vectorResponseOptions: any\n  ) => ResponseVector;\n}\n\nlet translationService: TranslationService;\n\nlet runtimeInitializedPromiseResolve: CallableFunction;\nconst runtimeInitializedPromise = new Promise(\n  (resolve) => (runtimeInitializedPromiseResolve = resolve)\n);\n\n// bergamot-translator-worker.js expects a \"Module\" object to be available\nlet workerWasmFilePath: string;\n\n(globalThis as any).Module = {\n  preRun: [\n    () => {\n      logTime(\"workerStart\", \"Time until Module.preRun\");\n      timing.moduleLoadStart = Date.now();\n    },\n  ],\n\n  locateFile: () => {\n    return workerWasmFilePath;\n  },\n\n  onRuntimeInitialized: async () => {\n    logTime(\n      \"moduleLoadStart\",\n      \"Wasm Runtime initialized Successfully (preRun -> onRuntimeInitialized)\"\n    );\n    runtimeInitializedPromiseResolve();\n  },\n} as any;\n\nasync function importBergamotWorker(\n  jsFilePath: string,\n  wasmFilePath: string | Buffer\n) {\n  if (typeof wasmFilePath === \"string\") {\n    workerWasmFilePath = wasmFilePath;\n  } else {\n    (globalThis as any).Module.wasmBinary = wasmFilePath;\n  }\n\n  if (isNode) {\n    const fs = require(\"fs\");\n    const code = fs.readFileSync(jsFilePath, \"utf-8\");\n    const vm = require(\"vm\");\n    vm.runInThisContext(code);\n  } else {\n    importScripts(jsFilePath);\n  }\n  await runtimeInitializedPromise;\n}\n\nasync function loadModel(\n  from: string,\n  to: string,\n  modelRegistry: ModelRegistry\n) {\n  timing.loadModelStart = Date.now();\n\n  try {\n    await constructTranslationService();\n    await constructTranslationModel(from, to, modelRegistry);\n    logTime(\"loadModelStart\", `Model '${from}-${to}' successfully constructed`);\n    return \"Model successfully loaded\";\n  } catch (error: any) {\n    console.error(error);\n    log(`Model '${from}${to}' construction failed:`, error.message);\n    return \"Model loading failed\";\n  }\n}\n\nfunction translate(\n  from: string,\n  to: string,\n  sentences: string[],\n  options: TranslationOptions[]\n) {\n  timing.translateStart = Date.now();\n\n  const wordCount = sentences.reduce(\n    (acc, sentence) => acc + _wordsCount(sentence),\n    0\n  );\n  let result;\n  try {\n    log(`Blocks to translate: ${sentences.length}`);\n    result = _translate(from, to, sentences, options);\n    const secs = (Date.now() - timing.translateStart) / 1000;\n    log(\n      `Speed: ${Math.round(\n        wordCount / secs\n      )} WPS (${wordCount} words in ${secs} secs)`\n    );\n  } catch (error: any) {\n    log(`Error:`, error.message);\n  }\n  return result;\n}\n\n// All variables specific to translation service\n\n// A map of language-pair to TranslationModel object\nconst languagePairToTranslationModels = new Map();\n\nconst PIVOT_LANGUAGE = \"en\";\n\nonmessage = async function (e) {\n  const command = e.data[0];\n  log(`Message '${command}' received from main script`);\n  if (command === \"translate\") {\n    const from = e.data[1];\n    const to = e.data[2];\n    const input = e.data[3];\n    const translateOptions = e.data[4];\n    const result = translate(from, to, input, translateOptions);\n    console.warn(result);\n    log(`'${command}' command done, Posting message back to main script`);\n    postMessage([`${command}_reply`, result]);\n  }\n};\n\n// Instantiates the Translation Service\nconst constructTranslationService = async () => {\n  if (!translationService) {\n    const config: TranslationServiceConfig = { cacheSize: 20000 };\n    log(`Creating Translation Service with config`, config);\n    translationService = new (globalThis as any).Module.BlockingService(config);\n    log(`Translation Service created successfully`);\n  }\n};\n\n// Constructs translation model(s) for the source and target language pair (using\n// pivoting if required).\nconst constructTranslationModel = async (\n  from: string,\n  to: string,\n  modelRegistry: ModelRegistry\n) => {\n  // Delete all previously constructed translation models and clear the map\n  languagePairToTranslationModels.forEach((value, key) => {\n    log(`Destructing model '${key}'`);\n    value.delete();\n  });\n  languagePairToTranslationModels.clear();\n\n  if (_isPivotingRequired(from, to)) {\n    // Pivoting requires 2 translation models\n    const languagePairSrcToPivot = _getLanguagePair(from, PIVOT_LANGUAGE);\n    const languagePairPivotToTarget = _getLanguagePair(PIVOT_LANGUAGE, to);\n    await Promise.all([\n      _constructTranslationModelHelper(languagePairSrcToPivot, modelRegistry),\n      _constructTranslationModelHelper(\n        languagePairPivotToTarget,\n        modelRegistry\n      ),\n    ]);\n  } else {\n    // Non-pivoting case requires only 1 translation model\n    await _constructTranslationModelHelper(\n      _getLanguagePair(from, to),\n      modelRegistry\n    );\n  }\n};\n\n// Translates text from source language to target language (via pivoting if necessary).\nconst _translate = (\n  from: string,\n  to: string,\n  input: string[],\n  translateOptions: TranslationOptions[]\n) => {\n  let vectorResponseOptions, vectorSourceText, vectorResponse;\n  try {\n    // Prepare the arguments (vectorResponseOptions and vectorSourceText (vector<string>)) of Translation API and call it.\n    // Result is a vector<Response> where each of its item corresponds to one item of vectorSourceText in the same order.\n    vectorResponseOptions = _prepareResponseOptions(translateOptions);\n    vectorSourceText = _prepareSourceText(input);\n\n    if (_isPivotingRequired(from, to)) {\n      // Translate via pivoting\n      const translationModelSrcToPivot = _getLoadedTranslationModel(\n        from,\n        PIVOT_LANGUAGE\n      );\n      const translationModelPivotToTarget = _getLoadedTranslationModel(\n        PIVOT_LANGUAGE,\n        to\n      );\n      vectorResponse = translationService.translateViaPivoting(\n        translationModelSrcToPivot,\n        translationModelPivotToTarget,\n        vectorSourceText,\n        vectorResponseOptions\n      );\n    } else {\n      // Translate without pivoting\n      const translationModel = _getLoadedTranslationModel(from, to);\n      vectorResponse = translationService.translate(\n        translationModel,\n        vectorSourceText,\n        vectorResponseOptions\n      );\n    }\n\n    // Parse all relevant information from vectorResponse\n    const listTranslatedText = _parseTranslatedText(vectorResponse);\n    const listSourceText = _parseSourceText(vectorResponse);\n    const listTranslatedTextSentences =\n      _parseTranslatedTextSentences(vectorResponse);\n    const listSourceTextSentences = _parseSourceTextSentences(vectorResponse);\n\n    log(`Source text: ${listSourceText}`);\n    log(`Translated text: ${listTranslatedText}`);\n    log(`Translated sentences: ${JSON.stringify(listTranslatedTextSentences)}`);\n    log(`Source sentences: ${JSON.stringify(listSourceTextSentences)}`);\n\n    return listTranslatedText;\n  } finally {\n    // Necessary clean up\n    if (vectorSourceText != null) vectorSourceText.delete();\n    if (vectorResponseOptions != null) vectorResponseOptions.delete();\n    if (vectorResponse != null) vectorResponse.delete();\n  }\n};\n\nconst _downloadAsArrayBufferNode = async (\n  url: string\n): Promise<ArrayBuffer> => {\n  const protocol = url.split(\"://\")[0];\n  const https = require(protocol);\n  return new Promise((resolve, reject) => {\n    const req = https.get(url, (res: IncomingMessage) => {\n      if (res.statusCode !== 200) {\n        reject(new Error(`Status code ${res.statusCode}`));\n        return;\n      }\n      const chunks: Buffer[] = [];\n      res.on(\"error\", (error: Error) => {\n        console.error(\"Error in fetching\", error);\n        reject(error);\n      });\n      res.on(\"data\", (chunk) => {\n        if (res.statusCode !== 200) {\n          reject(\"data: Status code is not 200\");\n        }\n        chunks.push(chunk);\n      });\n      res.on(\"end\", async () => {\n        if (res.statusCode !== 200) {\n          reject(\"end: Status code is not 200\");\n        }\n        const { Blob } = require(\"buffer\");\n        const data = new Blob(chunks);\n        try {\n          const buffer = await data.arrayBuffer();\n          resolve(buffer);\n        } catch (error) {\n          reject(error);\n        }\n      });\n    });\n\n    req.on(\"error\", function (e: any) {\n      // For some reason, firebase storage returns ECONNRESET while returning the right data\n      if (e.code !== \"ECONNRESET\") {\n        reject(e);\n      }\n    });\n    req.on(\"timeout\", function (e: any) {\n      console.error(`timeout: problem with request: ${e.message}`);\n      reject(e);\n    });\n    req.on(\"uncaughtException\", function (e: any) {\n      console.error(`uncaughtException: problem with request: ${e.message}`);\n      reject(e);\n    });\n  });\n};\n\n// Downloads file from a url and returns the array buffer\nconst _downloadAsArrayBuffer = async (url: string): Promise<ArrayBuffer> => {\n  if (isNode) {\n    return _downloadAsArrayBufferNode(url);\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw Error(\n      `Downloading ${url} failed: HTTP ${response.status} - ${response.statusText}`\n    );\n  }\n  return response.arrayBuffer();\n};\n\n// Constructs and initializes the AlignedMemory from the array buffer and alignment size\nconst _prepareAlignedMemoryFromBuffer = async (\n  buffer: ArrayBuffer,\n  alignmentSize: number\n) => {\n  const byteArray = new Int8Array(buffer);\n  const alignedMemory = new (globalThis as any).Module.AlignedMemory(\n    byteArray.byteLength,\n    alignmentSize\n  );\n  const alignedByteArrayView = alignedMemory.getByteArrayView();\n  alignedByteArrayView.set(byteArray);\n  return alignedMemory;\n};\n\nasync function prepareAlignedMemory(\n  file: FileInfo,\n  languagePair: string,\n  modelRegistry: ModelRegistry\n) {\n  const fileName = modelRegistry[languagePair][file.type].name;\n  const buffer = await _downloadAsArrayBuffer(fileName);\n  const alignedMemory = await _prepareAlignedMemoryFromBuffer(\n    buffer,\n    file.alignment\n  );\n  log(\n    `${\n      file.type\n    } aligned memory prepared. Size: ${alignedMemory.size()} bytes, alignment: ${\n      file.alignment\n    }`\n  );\n  return alignedMemory;\n}\n\nconst _constructTranslationModelHelper = async (\n  languagePair: string,\n  modelRegistry: ModelRegistry\n) => {\n  log(`Constructing translation model ${languagePair}`);\n\n  /*Set the Model Configuration as YAML formatted string.\n    For available configuration options, please check: https://marian-nmt.github.io/docs/cmd/marian-decoder/\n    Vocab files are re-used in both translation directions.\n    DO NOT CHANGE THE SPACES BETWEEN EACH ENTRY OF CONFIG\n  */\n  // Constraints:\n  // max-length-factor * max-length-break < mini-batch-words\n  const modelConfig = `beam-size: 12\nnormalize: 1.0\nword-penalty: 0\nmax-length-break: 512\nmini-batch-words: 8192\nworkspace: 512\nmax-length-factor: 12\nskip-cost: false\ncpu-threads: 0\nquiet: true\nquiet-translation: true\ngemm-precision: int8shiftAlphaAll\nalignment: soft\n`;\n\n  const alignedMemories = await Promise.all(\n    FILE_INFO.filter((file) => file.type in modelRegistry[languagePair]).map(\n      (file) => prepareAlignedMemory(file, languagePair, modelRegistry)\n    )\n  );\n\n  log(`Translation Model config: ${modelConfig}`);\n  log(\n    `Aligned memory sizes: Model:${alignedMemories[0].size()} Shortlist:${alignedMemories[1].size()} Vocab:${alignedMemories[2].size()}`\n  );\n  const alignedVocabMemoryList = new (\n    globalThis as any\n  ).Module.AlignedMemoryList();\n  alignedVocabMemoryList.push_back(alignedMemories[2]);\n  let translationModel;\n  if (alignedMemories.length === FILE_INFO.length) {\n    log(`QE:${alignedMemories[3].size()}`);\n    translationModel = new (globalThis as any).Module.TranslationModel(\n      modelConfig,\n      alignedMemories[0],\n      alignedMemories[1],\n      alignedVocabMemoryList,\n      alignedMemories[3]\n    );\n  } else {\n    translationModel = new (globalThis as any).Module.TranslationModel(\n      modelConfig,\n      alignedMemories[0],\n      alignedMemories[1],\n      alignedVocabMemoryList,\n      null\n    );\n  }\n  languagePairToTranslationModels.set(languagePair, translationModel);\n};\n\nconst _isPivotingRequired = (from: string, to: string) => {\n  return false;\n  // return from !== PIVOT_LANGUAGE && to !== PIVOT_LANGUAGE;\n};\n\nconst _getLanguagePair = (srcLang: string, tgtLang: string) => {\n  return `${srcLang}${tgtLang}`;\n};\n\nconst _getLoadedTranslationModel = (srcLang: string, tgtLang: string) => {\n  const languagePair = _getLanguagePair(srcLang, tgtLang);\n  if (!languagePairToTranslationModels.has(languagePair)) {\n    throw Error(`Translation model '${languagePair}' not loaded`);\n  }\n  return languagePairToTranslationModels.get(languagePair);\n};\n\nconst _parseTranslatedText = (vectorResponse: ResponseVector) => {\n  const result = [];\n  for (let i = 0; i < vectorResponse.size(); i++) {\n    const response = vectorResponse.get(i);\n    result.push(response.getTranslatedText());\n  }\n  return result;\n};\n\nconst _parseTranslatedTextSentences = (vectorResponse: ResponseVector) => {\n  const result = [];\n  for (let i = 0; i < vectorResponse.size(); i++) {\n    const response = vectorResponse.get(i);\n    result.push(_getTranslatedSentences(response));\n  }\n  return result;\n};\n\nconst _parseSourceText = (vectorResponse: ResponseVector) => {\n  const result = [];\n  for (let i = 0; i < vectorResponse.size(); i++) {\n    const response = vectorResponse.get(i);\n    result.push(response.getOriginalText());\n  }\n  return result;\n};\n\nconst _parseSourceTextSentences = (vectorResponse: ResponseVector) => {\n  const result = [];\n  for (let i = 0; i < vectorResponse.size(); i++) {\n    const response = vectorResponse.get(i);\n    result.push(_getSourceSentences(response));\n  }\n  return result;\n};\n\nconst _prepareResponseOptions = (translateOptions: TranslationOptions[]) => {\n  const vectorResponseOptions = new (\n    globalThis as any\n  ).Module.VectorResponseOptions();\n  translateOptions.forEach((translateOption) => {\n    vectorResponseOptions.push_back({\n      qualityScores: translateOption.isQualityScores,\n      alignment: true,\n      html: translateOption.isHtml,\n    });\n  });\n  if (vectorResponseOptions.size() == 0) {\n    vectorResponseOptions.delete();\n    throw Error(`No Translation Options provided`);\n  }\n  return vectorResponseOptions;\n};\n\nconst _prepareSourceText = (input: string[]) => {\n  const vectorSourceText = new (globalThis as any).Module.VectorString();\n  input.forEach((paragraph) => {\n    // prevent empty paragraph - it breaks the translation\n    if (paragraph.trim() === \"\") {\n      return;\n    }\n    vectorSourceText.push_back(paragraph.trim());\n  });\n  if (vectorSourceText.size() == 0) {\n    vectorSourceText.delete();\n    throw Error(`No text provided to translate`);\n  }\n  return vectorSourceText;\n};\n\ninterface Response {\n  getTranslatedText(): string;\n\n  getTranslatedSentence(index: number): { begin: number; end: number };\n\n  getSourceSentence(index: number): { begin: number; end: number };\n\n  size(): number;\n\n  getOriginalText(): string;\n}\n\ninterface ResponseVector {\n  size(): number;\n\n  get(index: number): Response;\n}\n\nconst _getTranslatedSentences = (response: Response) => {\n  const sentences = [];\n  const text = response.getTranslatedText();\n  for (\n    let sentenceIndex = 0;\n    sentenceIndex < response.size();\n    sentenceIndex++\n  ) {\n    const utf8SentenceByteRange = response.getTranslatedSentence(sentenceIndex);\n    sentences.push(_getSubString(text, utf8SentenceByteRange));\n  }\n  return sentences;\n};\n\nconst _getSourceSentences = (response: Response) => {\n  const sentences = [];\n  const text = response.getOriginalText();\n  for (\n    let sentenceIndex = 0;\n    sentenceIndex < response.size();\n    sentenceIndex++\n  ) {\n    const utf8SentenceByteRange = response.getSourceSentence(sentenceIndex);\n    sentences.push(_getSubString(text, utf8SentenceByteRange));\n  }\n  return sentences;\n};\n\n/*\n * Returns a substring of text (a string). The substring is represented by\n * byteRange (begin and end indices) within the utf-8 encoded version of the text.\n */\nconst _getSubString = (\n  text: string,\n  utf8ByteRange: { begin: number; end: number }\n) => {\n  const encoder = new TextEncoder(); // string to utf-8 converter\n  const decoder = new TextDecoder(); // utf-8 to string converter\n\n  const textUtf8ByteView = encoder.encode(text);\n  const substringUtf8ByteView = textUtf8ByteView.subarray(\n    utf8ByteRange.begin,\n    utf8ByteRange.end\n  );\n  return decoder.decode(substringUtf8ByteView);\n};\n\nfunction _wordsCount(sentence: string) {\n  return sentence\n    .trim()\n    .split(\" \")\n    .filter((word) => word.trim() !== \"\").length;\n}\n"],
  "mappings": "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",
  "names": ["isNode", "expose", "obj", "returnValue", "proxy"]
}
