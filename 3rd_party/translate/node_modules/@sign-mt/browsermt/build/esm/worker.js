import { isNode } from "browser-or-node";
import * as comlink from "comlink";
comlink.expose({ importBergamotWorker, loadModel, translate });
const timing = { workerStart: Date.now() };
const FILE_INFO = [
  { type: "model", alignment: 256 },
  { type: "lex", alignment: 64 },
  { type: "vocab", alignment: 64 },
  { type: "qualityModel", alignment: 64 }
];
function log(...args) {
  console.debug(...args);
}
function logTime(timingKey, ...args) {
  const time = (Date.now() - timing[timingKey]) / 1e3;
  log(...args, `${time} secs`);
}
let translationService;
let runtimeInitializedPromiseResolve;
const runtimeInitializedPromise = new Promise(
  (resolve) => runtimeInitializedPromiseResolve = resolve
);
let workerWasmFilePath;
globalThis.Module = {
  preRun: [
    () => {
      logTime("workerStart", "Time until Module.preRun");
      timing.moduleLoadStart = Date.now();
    }
  ],
  locateFile: () => {
    return workerWasmFilePath;
  },
  onRuntimeInitialized: async () => {
    logTime(
      "moduleLoadStart",
      "Wasm Runtime initialized Successfully (preRun -> onRuntimeInitialized)"
    );
    runtimeInitializedPromiseResolve();
  }
};
async function importBergamotWorker(jsFilePath, wasmFilePath) {
  if (typeof wasmFilePath === "string") {
    workerWasmFilePath = wasmFilePath;
  } else {
    globalThis.Module.wasmBinary = wasmFilePath;
  }
  if (isNode) {
    const fs = require("fs");
    const code = fs.readFileSync(jsFilePath, "utf-8");
    const vm = require("vm");
    vm.runInThisContext(code);
  } else {
    importScripts(jsFilePath);
  }
  await runtimeInitializedPromise;
}
async function loadModel(from, to, modelRegistry) {
  timing.loadModelStart = Date.now();
  try {
    await constructTranslationService();
    await constructTranslationModel(from, to, modelRegistry);
    logTime("loadModelStart", `Model '${from}-${to}' successfully constructed`);
    return "Model successfully loaded";
  } catch (error) {
    console.error(error);
    log(`Model '${from}${to}' construction failed:`, error.message);
    return "Model loading failed";
  }
}
function translate(from, to, sentences, options) {
  timing.translateStart = Date.now();
  const wordCount = sentences.reduce(
    (acc, sentence) => acc + _wordsCount(sentence),
    0
  );
  let result;
  try {
    log(`Blocks to translate: ${sentences.length}`);
    result = _translate(from, to, sentences, options);
    const secs = (Date.now() - timing.translateStart) / 1e3;
    log(
      `Speed: ${Math.round(
        wordCount / secs
      )} WPS (${wordCount} words in ${secs} secs)`
    );
  } catch (error) {
    log(`Error:`, error.message);
  }
  return result;
}
const languagePairToTranslationModels = /* @__PURE__ */ new Map();
const PIVOT_LANGUAGE = "en";
onmessage = async function(e) {
  const command = e.data[0];
  log(`Message '${command}' received from main script`);
  if (command === "translate") {
    const from = e.data[1];
    const to = e.data[2];
    const input = e.data[3];
    const translateOptions = e.data[4];
    const result = translate(from, to, input, translateOptions);
    console.warn(result);
    log(`'${command}' command done, Posting message back to main script`);
    postMessage([`${command}_reply`, result]);
  }
};
const constructTranslationService = async () => {
  if (!translationService) {
    const config = { cacheSize: 2e4 };
    log(`Creating Translation Service with config`, config);
    translationService = new globalThis.Module.BlockingService(config);
    log(`Translation Service created successfully`);
  }
};
const constructTranslationModel = async (from, to, modelRegistry) => {
  languagePairToTranslationModels.forEach((value, key) => {
    log(`Destructing model '${key}'`);
    value.delete();
  });
  languagePairToTranslationModels.clear();
  if (_isPivotingRequired(from, to)) {
    const languagePairSrcToPivot = _getLanguagePair(from, PIVOT_LANGUAGE);
    const languagePairPivotToTarget = _getLanguagePair(PIVOT_LANGUAGE, to);
    await Promise.all([
      _constructTranslationModelHelper(languagePairSrcToPivot, modelRegistry),
      _constructTranslationModelHelper(
        languagePairPivotToTarget,
        modelRegistry
      )
    ]);
  } else {
    await _constructTranslationModelHelper(
      _getLanguagePair(from, to),
      modelRegistry
    );
  }
};
const _translate = (from, to, input, translateOptions) => {
  let vectorResponseOptions, vectorSourceText, vectorResponse;
  try {
    vectorResponseOptions = _prepareResponseOptions(translateOptions);
    vectorSourceText = _prepareSourceText(input);
    if (_isPivotingRequired(from, to)) {
      const translationModelSrcToPivot = _getLoadedTranslationModel(
        from,
        PIVOT_LANGUAGE
      );
      const translationModelPivotToTarget = _getLoadedTranslationModel(
        PIVOT_LANGUAGE,
        to
      );
      vectorResponse = translationService.translateViaPivoting(
        translationModelSrcToPivot,
        translationModelPivotToTarget,
        vectorSourceText,
        vectorResponseOptions
      );
    } else {
      const translationModel = _getLoadedTranslationModel(from, to);
      vectorResponse = translationService.translate(
        translationModel,
        vectorSourceText,
        vectorResponseOptions
      );
    }
    const listTranslatedText = _parseTranslatedText(vectorResponse);
    const listSourceText = _parseSourceText(vectorResponse);
    const listTranslatedTextSentences = _parseTranslatedTextSentences(vectorResponse);
    const listSourceTextSentences = _parseSourceTextSentences(vectorResponse);
    log(`Source text: ${listSourceText}`);
    log(`Translated text: ${listTranslatedText}`);
    log(`Translated sentences: ${JSON.stringify(listTranslatedTextSentences)}`);
    log(`Source sentences: ${JSON.stringify(listSourceTextSentences)}`);
    return listTranslatedText;
  } finally {
    if (vectorSourceText != null)
      vectorSourceText.delete();
    if (vectorResponseOptions != null)
      vectorResponseOptions.delete();
    if (vectorResponse != null)
      vectorResponse.delete();
  }
};
const _downloadAsArrayBufferNode = async (url) => {
  const protocol = url.split("://")[0];
  const https = require(protocol);
  return new Promise((resolve, reject) => {
    const req = https.get(url, (res) => {
      if (res.statusCode !== 200) {
        reject(new Error(`Status code ${res.statusCode}`));
        return;
      }
      const chunks = [];
      res.on("error", (error) => {
        console.error("Error in fetching", error);
        reject(error);
      });
      res.on("data", (chunk) => {
        if (res.statusCode !== 200) {
          reject("data: Status code is not 200");
        }
        chunks.push(chunk);
      });
      res.on("end", async () => {
        if (res.statusCode !== 200) {
          reject("end: Status code is not 200");
        }
        const { Blob } = require("buffer");
        const data = new Blob(chunks);
        try {
          const buffer = await data.arrayBuffer();
          resolve(buffer);
        } catch (error) {
          reject(error);
        }
      });
    });
    req.on("error", function(e) {
      if (e.code !== "ECONNRESET") {
        reject(e);
      }
    });
    req.on("timeout", function(e) {
      console.error(`timeout: problem with request: ${e.message}`);
      reject(e);
    });
    req.on("uncaughtException", function(e) {
      console.error(`uncaughtException: problem with request: ${e.message}`);
      reject(e);
    });
  });
};
const _downloadAsArrayBuffer = async (url) => {
  if (isNode) {
    return _downloadAsArrayBufferNode(url);
  }
  const response = await fetch(url);
  if (!response.ok) {
    throw Error(
      `Downloading ${url} failed: HTTP ${response.status} - ${response.statusText}`
    );
  }
  return response.arrayBuffer();
};
const _prepareAlignedMemoryFromBuffer = async (buffer, alignmentSize) => {
  const byteArray = new Int8Array(buffer);
  const alignedMemory = new globalThis.Module.AlignedMemory(
    byteArray.byteLength,
    alignmentSize
  );
  const alignedByteArrayView = alignedMemory.getByteArrayView();
  alignedByteArrayView.set(byteArray);
  return alignedMemory;
};
async function prepareAlignedMemory(file, languagePair, modelRegistry) {
  const fileName = modelRegistry[languagePair][file.type].name;
  const buffer = await _downloadAsArrayBuffer(fileName);
  const alignedMemory = await _prepareAlignedMemoryFromBuffer(
    buffer,
    file.alignment
  );
  log(
    `${file.type} aligned memory prepared. Size: ${alignedMemory.size()} bytes, alignment: ${file.alignment}`
  );
  return alignedMemory;
}
const _constructTranslationModelHelper = async (languagePair, modelRegistry) => {
  log(`Constructing translation model ${languagePair}`);
  const modelConfig = `beam-size: 12
normalize: 1.0
word-penalty: 0
max-length-break: 512
mini-batch-words: 8192
workspace: 512
max-length-factor: 12
skip-cost: false
cpu-threads: 0
quiet: true
quiet-translation: true
gemm-precision: int8shiftAlphaAll
alignment: soft
`;
  const alignedMemories = await Promise.all(
    FILE_INFO.filter((file) => file.type in modelRegistry[languagePair]).map(
      (file) => prepareAlignedMemory(file, languagePair, modelRegistry)
    )
  );
  log(`Translation Model config: ${modelConfig}`);
  log(
    `Aligned memory sizes: Model:${alignedMemories[0].size()} Shortlist:${alignedMemories[1].size()} Vocab:${alignedMemories[2].size()}`
  );
  const alignedVocabMemoryList = new globalThis.Module.AlignedMemoryList();
  alignedVocabMemoryList.push_back(alignedMemories[2]);
  let translationModel;
  if (alignedMemories.length === FILE_INFO.length) {
    log(`QE:${alignedMemories[3].size()}`);
    translationModel = new globalThis.Module.TranslationModel(
      modelConfig,
      alignedMemories[0],
      alignedMemories[1],
      alignedVocabMemoryList,
      alignedMemories[3]
    );
  } else {
    translationModel = new globalThis.Module.TranslationModel(
      modelConfig,
      alignedMemories[0],
      alignedMemories[1],
      alignedVocabMemoryList,
      null
    );
  }
  languagePairToTranslationModels.set(languagePair, translationModel);
};
const _isPivotingRequired = (from, to) => {
  return false;
};
const _getLanguagePair = (srcLang, tgtLang) => {
  return `${srcLang}${tgtLang}`;
};
const _getLoadedTranslationModel = (srcLang, tgtLang) => {
  const languagePair = _getLanguagePair(srcLang, tgtLang);
  if (!languagePairToTranslationModels.has(languagePair)) {
    throw Error(`Translation model '${languagePair}' not loaded`);
  }
  return languagePairToTranslationModels.get(languagePair);
};
const _parseTranslatedText = (vectorResponse) => {
  const result = [];
  for (let i = 0; i < vectorResponse.size(); i++) {
    const response = vectorResponse.get(i);
    result.push(response.getTranslatedText());
  }
  return result;
};
const _parseTranslatedTextSentences = (vectorResponse) => {
  const result = [];
  for (let i = 0; i < vectorResponse.size(); i++) {
    const response = vectorResponse.get(i);
    result.push(_getTranslatedSentences(response));
  }
  return result;
};
const _parseSourceText = (vectorResponse) => {
  const result = [];
  for (let i = 0; i < vectorResponse.size(); i++) {
    const response = vectorResponse.get(i);
    result.push(response.getOriginalText());
  }
  return result;
};
const _parseSourceTextSentences = (vectorResponse) => {
  const result = [];
  for (let i = 0; i < vectorResponse.size(); i++) {
    const response = vectorResponse.get(i);
    result.push(_getSourceSentences(response));
  }
  return result;
};
const _prepareResponseOptions = (translateOptions) => {
  const vectorResponseOptions = new globalThis.Module.VectorResponseOptions();
  translateOptions.forEach((translateOption) => {
    vectorResponseOptions.push_back({
      qualityScores: translateOption.isQualityScores,
      alignment: true,
      html: translateOption.isHtml
    });
  });
  if (vectorResponseOptions.size() == 0) {
    vectorResponseOptions.delete();
    throw Error(`No Translation Options provided`);
  }
  return vectorResponseOptions;
};
const _prepareSourceText = (input) => {
  const vectorSourceText = new globalThis.Module.VectorString();
  input.forEach((paragraph) => {
    if (paragraph.trim() === "") {
      return;
    }
    vectorSourceText.push_back(paragraph.trim());
  });
  if (vectorSourceText.size() == 0) {
    vectorSourceText.delete();
    throw Error(`No text provided to translate`);
  }
  return vectorSourceText;
};
const _getTranslatedSentences = (response) => {
  const sentences = [];
  const text = response.getTranslatedText();
  for (let sentenceIndex = 0; sentenceIndex < response.size(); sentenceIndex++) {
    const utf8SentenceByteRange = response.getTranslatedSentence(sentenceIndex);
    sentences.push(_getSubString(text, utf8SentenceByteRange));
  }
  return sentences;
};
const _getSourceSentences = (response) => {
  const sentences = [];
  const text = response.getOriginalText();
  for (let sentenceIndex = 0; sentenceIndex < response.size(); sentenceIndex++) {
    const utf8SentenceByteRange = response.getSourceSentence(sentenceIndex);
    sentences.push(_getSubString(text, utf8SentenceByteRange));
  }
  return sentences;
};
const _getSubString = (text, utf8ByteRange) => {
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  const textUtf8ByteView = encoder.encode(text);
  const substringUtf8ByteView = textUtf8ByteView.subarray(
    utf8ByteRange.begin,
    utf8ByteRange.end
  );
  return decoder.decode(substringUtf8ByteView);
};
function _wordsCount(sentence) {
  return sentence.trim().split(" ").filter((word) => word.trim() !== "").length;
}
//# sourceMappingURL=worker.js.map
