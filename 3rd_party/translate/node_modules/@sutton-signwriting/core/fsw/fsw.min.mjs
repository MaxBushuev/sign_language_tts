/* Sutton SignWriting Core Module v2.0.0 (https://github.com/sutton-signwriting/core), author: Steve Slevinski (https://SteveSlevinski.me), license: MIT */
let e={null:"S00000",symbol:"S[123][0-9a-f]{2}[0-5][0-9a-f]",coord:"[0-9]{3}x[0-9]{3}",sort:"A",box:"[BLMR]"};e.nullorsymbol=`(?:${e.null}|${e.symbol})`,e.prefix=`(?:${e.sort}${e.nullorsymbol}+)`,e.spatial=`${e.symbol}${e.coord}`,e.signbox=`${e.box}${e.coord}(?:${e.spatial})*`,e.sign=`${e.prefix}?${e.signbox}`,e.sortable=`${e.prefix}${e.signbox}`;let t={colorize:"C",colorhex:"(?:[0-9a-fA-F]{3}){1,2}",colorname:"[a-zA-Z]+",padding:"P[0-9]{2}",zoom:"Z(?:[0-9]+(?:\\.[0-9]+)?|x)",classbase:"-?[_a-zA-Z][_a-zA-Z0-9-]{0,100}",id:"[a-zA-Z][_a-zA-Z0-9-]{0,100}"};t.colorbase=`(?:${t.colorhex}|${t.colorname})`,t.color=`_${t.colorbase}_`,t.colors=`_${t.colorbase}(?:,${t.colorbase})?_`,t.background=`G${t.color}`,t.detail=`D${t.colors}`,t.detailsym=`D[0-9]{2}${t.colors}`,t.classes=`${t.classbase}(?: ${t.classbase})*`,t.full=`-(${t.colorize})?(${t.padding})?(${t.background})?(${t.detail})?(${t.zoom})?(?:-((?:${t.detailsym})*))?(?:-(${t.classes})?!(?:(${t.id})!)?)?`;const o=e=>(new RegExp(`^${t.colorhex}$`).test(e)?"#":"")+e,n=e=>{const n=`^${t.full}`,s=("string"==typeof e?e.match(new RegExp(n)):[])||[];return a={colorize:s[1]?!!s[1]:void 0,padding:s[2]?parseInt(s[2].slice(1)):void 0,background:s[3]?o(s[3].slice(2,-1)):void 0,detail:s[4]?s[4].slice(2,-1).split(",").map(o):void 0,zoom:s[5]?"Zx"===s[5]?"x":parseFloat(s[5].slice(1)):void 0,detailsym:s[6]?s[6].match(new RegExp(t.detailsym,"g")).map((e=>{const t=e.split("_"),n=t[1].split(",").map(o);return{index:parseInt(t[0].slice(1)),detail:n}})):void 0,classes:s[7]?s[7]:void 0,id:s[8]?s[8]:void 0},Object.fromEntries(Object.entries(a).filter((([e,t])=>void 0!==t)));var a},s=e=>e.split("x").map((e=>parseInt(e))),a={symbol:o=>{const n=`^(${e.symbol})(${e.coord})?(${t.full})?`,a="string"==typeof o?o.match(new RegExp(n)):void 0;return{symbol:a?a[1]:void 0,coord:a&&a[2]?s(a[2]):void 0,style:a?a[3]:void 0}},sign:o=>{const n=`^(${e.prefix})?(${e.signbox})(${t.full})?`,a="string"==typeof o?o.match(new RegExp(n)):void 0;return a?{sequence:a[1]?a[1].slice(1).match(/.{6}/g):void 0,box:a[2][0],max:s(a[2].slice(1,8)),spatials:a[2].length<9?void 0:a[2].slice(8).match(/(.{13})/g).map((e=>({symbol:e.slice(0,6),coord:[parseInt(e.slice(6,9)),parseInt(e.slice(10,13))]}))),style:a[3]}:{}},text:o=>{if("string"!=typeof o)return[];const n=`(${e.sign}(${t.full})?|${e.spatial}(${t.full})?)`,s=o.match(new RegExp(n,"g"));return s?[...s]:[]}},l={symbol:o=>{if("string"==typeof o.symbol){const n=(o.symbol.match(e.symbol)||[""])[0];if(n){return n+((((o.coord&&o.coord[0]||"").toString()+"x"+(o.coord&&o.coord[1]||"").toString()).match(e.coord)||[""])[0]||"")+("string"==typeof o.style&&(o.style.match(t.full)||[""])[0]||"")}}},sign:o=>{let n="string"!=typeof o.box?"M":(o.box+"M").match(e.box);const s=(((o.max&&o.max[0]||"").toString()+"x"+(o.max&&o.max[1]||"").toString()).match(e.coord)||[""])[0]||"";if(!s)return;let a="";o.sequence&&Array.isArray(o.sequence)&&(a=o.sequence.map((t=>(t.match(e.nullorsymbol)||[""])[0])).join(""),a=a?"A"+a:"");let l="";o.spatials&&Array.isArray(o.spatials)&&(l=o.spatials.map((t=>{if("string"==typeof t.symbol){const o=(t.symbol.match(e.symbol)||[""])[0];if(o){const n=(((t.coord&&t.coord[0]||"").toString()+"x"+(t.coord&&t.coord[1]||"").toString()).match(e.coord)||[""])[0]||"";if(n)return o+n}}return""})).join(""));return a+n+s+l+("string"==typeof o.style&&(o.style.match(t.full)||[""])[0]||"")}},r=e=>{let t,o,s,l,r,i,c,d,p=a.sign(e);p.spatials?(l=Math.min(...p.spatials.map((e=>e.coord[0]))),r=p.max[0],t=r-l,i=Math.min(...p.spatials.map((e=>e.coord[1]))),c=p.max[1],o=c-i,s="sign",d=p.box):(p=a.symbol(e),d="M",p.coord?(l=p.coord[0],t=2*(500-l),i=p.coord[1],o=2*(500-i),s="symbol"):(l=490,t=20,i=490,o=20,s="none"));let m=n(p.style),u=m.zoom||1,g=m.padding||0;return{minX:l,minY:i,width:t,height:o,segment:s,lane:{B:0,L:-1,M:0,R:1}[d],padding:g,zoom:u}},i=[{index:0,name:"UNK",value:"[UNK]"},{index:1,name:"PAD",value:"[PAD]"},{index:2,name:"CLS",value:"[CLS]"},{index:3,name:"SEP",value:"[SEP]"}],c=(e,{sequence:t=!0,signbox:o=!0,sep:n="[SEP]"}={})=>{const s=e=>[e.slice(0,4),`c${e.charAt(4)}`,`r${e.charAt(5)}`],l=e=>e.map((e=>`p${e}`));return a.text(e).map((e=>{if(/[BLMR]/.test(e)){const r=a.sign(e),i=[];return r.sequence&&t&&i.push("A",...r.sequence.map((e=>s(e))).flat()),o&&i.push(r.box,...l(r.max),...r.spatials.flatMap((e=>[...s(e.symbol),...l(e.coord)]))),n?[...i,n]:i}{const r=a.symbol(e);if(!o&&!t)return[];let i=[];return i=!o&&t?["A",...s(r.symbol)]:["M",...l(r.coord.map((e=>1e3-e))),...s(r.symbol),...l(r.coord)],i.length>0&&n?[...i,n]:i}})).flatMap((e=>e))},d=(e,t=i)=>{const o=new Set(t.map((e=>e.value)));return e.filter((e=>!o.has(e))).join(" ").replace(/\bp(\d{3})\s+p(\d{3})/g,"$1x$2").replace(/ c(\d)\d? r(.)/g,"$1$2").replace(/ c(\d)\d?/g,"$10").replace(/ r(.)/g,"0$1").replace(/ /g,"").replace(/(\d)([BLMR])/g,"$1 $2").replace(/(\d)(AS)/g,"$1 $2").replace(/(A(?:S00000|S[123][0-9a-f]{2}[0-5][0-9a-f])+)( )([BLMR])/g,"$1$3")},p=(e=i,t=null)=>{const o=(e=>{const t={},o={},n={},s=new Set;return e.forEach((e=>{if(s.has(e.index))throw new Error(`Duplicate token index: ${e.index}`);s.add(e.index),t[e.index]=e,o[e.name]=e,n[e.value]=e})),{byIndex:t,byName:o,byValue:n,getByIndex:o=>t[o]||t[e.find((e=>"UNK"===e.name)).index],getByName:e=>o[e]||o.UNK,getByValue:e=>n[e]||o.UNK,getAllValues:()=>e.map((e=>e.value)),getAllIndices:()=>e.map((e=>e.index))}})(e),n=t??(o.getAllIndices().length>0?Math.max(...o.getAllIndices())+1:0),s=(()=>{const e=(e,t)=>Array.from({length:t-e},((t,o)=>e+o)),t=(t,o)=>e(t,o+1).map((e=>e.toString(16)));return["A","B","L","M","R","S000",...e(256,908).map((e=>`S${e.toString(16)}`)),...t(0,15).map((e=>`r${e}`)),...t(0,5).map((e=>`c${e}`)),...e(250,750).map((e=>`p${e}`))]})(),{i2s:a,s2i:l}=((e,t,o)=>{const n={},s={};return Object.values(t.byIndex).forEach((e=>{n[e.index]=e.value,s[e.value]=e.index})),e.forEach(((e,t)=>{const a=o+t;n[a]=e,s[e]=a})),{i2s:n,s2i:s}})(s,o,n),r={i2s:a,s2i:l,specialTokens:o,length:Object.keys(a).length,vocab:()=>Object.values(a),encodeTokens:e=>e.map((e=>void 0!==l[e]?l[e]:o.getByValue(e).index)),decodeTokens:e=>e.map((e=>a[e]||o.getByName("UNK").value)),encode:(e,t={})=>{const n=c(e,{...t,sep:o.getByName("SEP").value});return r.encodeTokens(n)},decode:t=>{if(0===t.length)return"";if(Array.isArray(t[0])){const o=t.map((e=>r.decodeTokens(e)));return d(o.flat(),e)}const o=r.decodeTokens(t);return d(o,e)},chunk:(e,t)=>((e,t,{cls:o="[CLS]",sep:n="[SEP]",pad:s="[PAD]"}={})=>{if(t<60)throw new Error("Chunk size must be at least 60 tokens to accommodate a typical sign");const a=[];let l=[],r=0;for(;r<e.length;){for(l=[o];r<e.length;){e[r];let o=r;for(;o<e.length&&e[o]!==n;)o++;const s=o-r+1;if(l.length+s>t-1)break;for(;r<=o;)l.push(e[r]),r++}for(;l.length<t;)l.push(s);a.push(l)}return a})(e,t,{cls:o.getByName("CLS").value,sep:o.getByName("SEP").value,pad:o.getByName("PAD").value})};return r},m={height:500,width:150,offset:50,pad:20,margin:5,dynamic:!1,background:void 0,punctuation:{spacing:!0,pad:30,pull:!0},style:{detail:["black","white"],zoom:1}},u=e=>("object"!=typeof e&&(e={}),{...m,...e,punctuation:{...m.punctuation,...e.punctuation},style:{...m.style,...e.style}}),g=(e,t)=>{if("string"!=typeof e)return{};const o=u(t);let n=a.text(e),s=0,l=[],i=[],c=0,d=parseInt(o.width/2),p=o.height-o.margin,m=!0,g=!1;for(let e of n){let t=r(e);s+=c,o.punctuation.spacing?s+="sign"==t.segment?o.pad:0:s+=o.pad,g=s+t.height>p,g&&"symbol"==t.segment&&o.punctuation.pull&&m&&(g=!1,m=!1),0==i.length&&(g=!1),g&&(s=o.pad,l.push(i),i=[],m=!0),i.push(Object.assign(t,{x:d+o.offset*t.lane-(500-t.minX)*t.zoom*o.style.zoom,y:s,text:e})),s+=t.height*t.zoom*o.style.zoom,c=o.punctuation.spacing?"sign"==t.segment?o.pad:o.punctuation.pad:o.pad}if(i.length&&l.push(i),o.punctuation.pull)for(let e of l){let t=e[e.length-1],n=t.y+t.height-(o.height-o.margin);if(n>0){let t=parseInt(n/e.length)+1;for(let o in e)e[o].y-=t*o+t}}let h=[];for(let e of l){let t=[d-o.offset-o.pad],n=[d+o.offset+o.pad];for(let s of e)t.push(s.x-o.pad),n.push(s.x+s.width+o.pad);t=Math.min(...t),n=Math.max(...n);let s=o.width,a=0;o.dynamic?(s=n-t,a=-t):a=d-parseInt((t+n)/2);for(let t of e)t.x+=a;h.push(s)}return{options:o,widths:h,columns:l}},h=[256,895,903],y=[256,517,759,767,877,895,903],f=[256,270,286,324,332,390,420,442,461,501,517,534,554,597,613,648,678,695,725,739,759,767,778,810,827,857,877,886,895,903],x={all:[256,907],writing:[256,894],hand:[256,516],movement:[517,758],dynamic:[759,766],head:[767,876],hcenter:[767,876],vcenter:[767,885],trunk:[877,885],limb:[886,894],location:[895,902],punctuation:[903,907]},b=(e,t)=>{const o=a.symbol(e);if(o.symbol){const e=parseInt(o.symbol.slice(1,4),16),n=x[t];if(n)return n[0]<=e&&n[1]>=e}return!1},$=["#0000CC","#CC0000","#FF0099","#006600","#000000","#884411","#FF9900"],v=e=>{const t=a.symbol(e);let o="#000000";if(t.symbol){const e=parseInt(t.symbol.slice(1,4),16),n=y.findIndex((t=>t>e));o=$[n<0?6:n-1]}return o};export{y as category,v as colorize,$ as colors,m as columnDefaults,u as columnDefaultsMerge,g as columns,l as compose,p as createTokenizer,d as detokenize,f as group,r as info,b as isType,h as kind,a as parse,x as ranges,e as re,c as tokenize};
