export const __esModule: boolean;
declare var index$4: Readonly<{
    __proto__: any;
    swu2mark: (swuMark: string) => string;
    mark2swu: (fswMark: string) => string;
    swu2num: (swuNum: string) => number;
    num2swu: (num: number) => string;
    swu2coord: (swuCoord: string) => number[];
    coord2swu: (coord: number[]) => string;
    fsw2coord: (fswCoord: string) => number[];
    coord2fsw: (coord: number[]) => string;
    swu2code: (swuSym: string) => number;
    code2swu: (code: number) => string;
    swu2id: (swuSym: string) => number;
    id2swu: (id: number) => string;
    key2id: (key: string) => number;
    id2key: (id: number) => string;
    swu2key: (swuSym: string) => string;
    key2swu: (key: string) => string;
    swu2fsw: (swuText: string) => string;
    fsw2swu: (fswText: string) => string;
    symidArr: string[];
    symidMax: (symidMin: string) => string;
    symidMin: (symidMax: string) => string;
    symid2key: (symid: string) => string;
    key2symid: (key: string) => string;
}>;
/** The fsw module contains functions for handling Formal SignWriting in ASCII (FSW) characters.
 * [FSW characters definition](https://tools.ietf.org/id/draft-slevinski-formal-signwriting-09.html#name-formal-signwriting-in-ascii)
 * @module fsw
 */
declare var index$3: Readonly<{
    __proto__: any;
    re: {
        symbol: string;
        coord: string;
        sort: string;
        box: string;
    };
    parse: {
        /**
         * Function to parse an fsw symbol with optional coordinate and style string
         * @function fsw.parse.symbol
         * @param {string} fswSym - an fsw symbol
         * @returns {SymbolObject} elements of fsw symbol
         * @example
         * fsw.parse.symbol('S10000500x500-C')
         *
         * return {
         *  'symbol': 'S10000',
         *  'coord': [500, 500],
         *  'style': '-C'
         * }
         */
        symbol: (fswSym: string) => SymbolObject;
        /**
         * Function to parse an fsw sign with style string
         * @function fsw.parse.sign
         * @param {string} fswSign - an fsw sign
         * @returns { SignObject } elements of fsw sign
         * @example
         * fsw.parse.sign('AS10011S10019S2e704S2e748M525x535S2e748483x510S10011501x466S2e704510x500S10019476x475-C')
         *
         * return {
         *  sequence: ['S10011', 'S10019', 'S2e704', 'S2e748'],
         *  box: 'M',
         *  max: [525, 535],
         *  spatials: [
         *    {
         *      symbol: 'S2e748',
         *      coord: [483, 510]
         *    },
         *    {
         *      symbol: 'S10011',
         *      coord: [501, 466]
         *    },
         *    {
         *      symbol: 'S2e704',
         *      coord: [510, 500]
         *    },
         *    {
         *      symbol: 'S10019',
         *      coord: [476, 475]
         *    }
         *  ],
         *  style: '-C'
         * }
         */
        sign: (fswSign: string) => SignObject;
        /**
         * Function to parse an fsw text
         * @function fsw.parse.text
         * @param {string} fswText - an fsw text
         * @returns {string[]} fsw signs and punctuations
         * @example
         * fsw.parse.text('AS14c20S27106M518x529S14c20481x471S27106503x489 AS18701S1870aS2e734S20500M518x533S1870a489x515S18701482x490S20500508x496S2e734500x468 S38800464x496')
         *
         * return [
         *  'AS14c20S27106M518x529S14c20481x471S27106503x489',
         *  'AS18701S1870aS2e734S20500M518x533S1870a489x515S18701482x490S20500508x496S2e734500x468',
         *  'S38800464x496'
         * ]
         */
        text: (fswText: string) => string[];
    };
    compose: {
        /**
         * Function to compose an fsw symbol with optional coordinate and style string
         * @function fsw.compose.symbol
         * @param {SymbolObject} fswSymObject - an fsw symbol object
         * @returns {string} an fsw symbol string
         * @example
         * fsw.compose.symbol({
         *  'symbol': 'S10000',
         *  'coord': [480, 480],
         *  'style': '-C'
         * })
         *
         * return 'S10000480x480-C'
         */
        symbol: (fswSymObject: SymbolObject) => string;
        /**
         * Function to compose an fsw sign with style string
         * @function fsw.compose.sign
         * @param {SignObject} fswSignObject - an fsw symbol object
         * @returns {string} an fsw sign string
         * @example
         * fsw.compose.sign({
         *  sequence: ['S10011', 'S10019', 'S2e704', 'S2e748'],
         *  box: 'M',
         *  max: [525, 535],
         *  spatials: [
         *    {
         *      symbol: 'S2e748',
         *      coord: [483, 510]
         *    },
         *    {
         *      symbol: 'S10011',
         *      coord: [501, 466]
         *    },
         *    {
         *      symbol: 'S2e704',
         *      coord: [510, 500]
         *    },
         *    {
         *      symbol: 'S10019',
         *      coord: [476, 475]
         *    }
         *  ],
         *  style: '-C'
         * })
         *
         * return 'AS10011S10019S2e704S2e748M525x535S2e748483x510S10011501x466S2e704510x500S10019476x475-C'
         */
        sign: (fswSignObject: SignObject) => string;
    };
    info: (fsw: string) => SegmentInfo;
    columnDefaults: {
        height: number;
        width: number;
        offset: number;
        pad: number;
        margin: number;
        dynamic: boolean;
        background: any;
        punctuation: {
            spacing: boolean;
            pad: number;
            pull: boolean;
        };
        style: {
            detail: string[];
            zoom: number;
        };
    };
    columnDefaultsMerge: (options: ColumnOptions) => ColumnOptions;
    columns: (fswText: string, options: ColumnOptions) => {
        options: ColumnOptions;
        widths: number[];
        columns: ColumnData;
    };
    kind: number[];
    category: number[];
    group: number[];
    ranges: any;
    isType: (key: string, type: string) => boolean;
    colors: string[];
    colorize: (key: string) => string;
}>;
/** The fswquery module contains functions for handling the FSW query language.
 * [Query Language definition](https://tools.ietf.org/id/draft-slevinski-formal-signwriting-09.html#name-query-language)
 * @module fswquery
 */
declare var index$2: Readonly<{
    __proto__: any;
    re: any;
    parse: (fswQueryString: string) => QueryObject;
    compose: (fswQueryObject: QueryObject) => string;
    fsw2query: (fswSign: string, flags: string) => string;
    range: (min: (number | string), max: (number | string), hex: boolean | null) => string;
    regex: (query: string) => string[];
    results: (query: string, text: string) => string[];
    lines: (query: string, text: string) => string[];
}>;
/** The style module contains regular expressions and functions for parsing and composing style strings.
 * [Style string definition](https://tools.ietf.org/id/draft-slevinski-formal-signwriting-09.html#name-styling-string)
 * @module style
 */
declare var index$5: Readonly<{
    __proto__: any;
    re: any;
    parse: (styleString: string) => StyleObject;
    compose: (styleObject: StyleObject) => string;
    merge: (style1: StyleObject, style2: StyleObject) => StyleObject;
    rgb2hex: (rgb: string, tolerance?: number) => string;
    rgba2hex: (color: string, background: string) => string;
}>;
/** The swu module contains functions for handling SignWriting in Unicode (SWU) characters.
 * [SWU characters definition](https://tools.ietf.org/id/draft-slevinski-formal-signwriting-09.html#name-signwriting-in-unicode-swu)
 * @module swu
 */
declare var index$1: Readonly<{
    __proto__: any;
    re: {
        symbol: string;
        coord: string;
        sort: string;
        box: string;
    };
    parse: {
        /**
         * Function to parse an swu symbol with optional coordinate and style string
         * @function swu.parse.symbol
         * @param {string} swuSym - an swu symbol
         * @returns {SymbolObject} elements of swu symbol
         * @example
         * swu.parse.symbol('񀀁𝤆𝤆-C')
         *
         * return {
         *  'symbol': '񀀁',
         *  'coord': [500, 500],
         *  'style': '-C'
         * }
         */
        symbol: (swuSym: string) => SymbolObject;
        /**
          * Function to parse an swu sign with style string
          * @function swu.parse.sign
          * @param {string} swuSign - an swu sign
          * @returns {SignObject} elements of swu sign
          * @example
          * swu.parse.sign('𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭-C')
          *
          * return {
          *  sequence: ['񀀒','񀀚','񋚥','񋛩'],
          *  box: '𝠃',
          *  max: [525, 535],
          *  spatials: [
          *    {
          *      symbol: '񋛩',
          *      coord: [483, 510]
          *    },
          *    {
          *      symbol: '񀀒',
          *      coord: [501, 466]
          *    },
          *    {
          *      symbol: '񋚥',
          *      coord: [510, 500]
          *    },
          *    {
          *      symbol: '񀀚',
          *      coord: [476, 475]
          *    }
          *  ],
          *  style: '-C'
          * }
          */
        sign: (swuSign: string) => SignObject;
        /**
         * Function to parse an swu text
         * @function swu.parse.text
         * @param {string} swuText - an swu text
         * @returns {string[]} swu signs and punctuations
         * @example
         * swu.parse.text('𝠀񁲡񈩧𝠃𝤘𝤣񁲡𝣳𝣩񈩧𝤉𝣻 𝠀񃊢񃊫񋛕񆇡𝠃𝤘𝤧񃊫𝣻𝤕񃊢𝣴𝣼񆇡𝤎𝤂񋛕𝤆𝣦 񏌁𝣢𝤂')
         *
         * return [
         *  '𝠀񁲡񈩧𝠃𝤘𝤣񁲡𝣳𝣩񈩧𝤉𝣻',
         *  '𝠀񃊢񃊫񋛕񆇡𝠃𝤘𝤧񃊫𝣻𝤕񃊢𝣴𝣼񆇡𝤎𝤂񋛕𝤆𝣦',
         *  '񏌁𝣢𝤂'
         * ]
         */
        text: (swuText: string) => string[];
    };
    encode: (swu: string) => string;
    decode: (encoded: string) => string;
    pair: (swuChar: string) => string[];
    compose: {
        /**
         * Function to compose an swu symbol with optional coordinate and style string
         * @function swu.compose.symbol
         * @param {SymbolObject} swuSymObject - an swu symbol object
         * @returns {string} an swu symbol string
         * @example
         * swu.compose.symbol({
         *  'symbol': '񀀁',
         *  'coord': [500, 500],
         *  'style': '-C'
         * })
         *
         * return '񀀁𝤆𝤆-C'
         */
        symbol: (swuSymObject: SymbolObject) => string;
        /**
         * Function to compose an swu sign with style string
         * @function swu.compose.sign
         * @param {SignObject} swuSignObject - an swu sign object
         * @returns {string} an swu sign string
         * @example
         * swu.compose.sign({
         *  sequence: ['񀀒','񀀚','񋚥','񋛩'],
         *  box: '𝠃',
         *  max: [525, 535],
         *  spatials: [
         *    {
         *      symbol: '񋛩',
         *      coord: [483, 510]
         *    },
         *    {
         *      symbol: '񀀒',
         *      coord: [501, 466]
         *    },
         *    {
         *      symbol: '񋚥',
         *      coord: [510, 500]
         *    },
         *    {
         *      symbol: '񀀚',
         *      coord: [476, 475]
         *    }
         *  ],
         *  style: '-C'
         * })
         *
         * return '𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭-C'
         */
        sign: (swuSignObject: SignObject) => string;
    };
    info: (swu: string) => SegmentInfo;
    columnDefaults: {
        height: number;
        width: number;
        offset: number;
        pad: number;
        margin: number;
        dynamic: boolean;
        background: any;
        punctuation: {
            spacing: boolean;
            pad: number;
            pull: boolean;
        };
        style: {
            detail: string[];
            zoom: number;
        };
    };
    columnDefaultsMerge: (options: ColumnOptions) => ColumnOptions;
    columns: (swuText: string, options: ColumnOptions) => {
        options: ColumnOptions;
        widths: number[];
        columns: ColumnData;
    };
    kind: any[];
    category: any[];
    group: any[];
    ranges: any;
    isType: (swuSym: string, type: string) => boolean;
    colors: any[];
    colorize: (swuSym: string) => string;
}>;
/** The swuquery module contains functions for handling the SWU query language.
 * [Query Language definition](https://tools.ietf.org/id/draft-slevinski-formal-signwriting-09.html#name-query-language)
 * @module swuquery
 */
declare var index: Readonly<{
    __proto__: any;
    re: any;
    parse: (swuQueryString: string) => QueryObject;
    compose: (swuQueryObject: QueryObject) => string;
    swu2query: (swuSign: string, flags: string) => string;
    range: (min: string, max: string) => string;
    symbolRanges: (symbolFR: string) => string;
    regex: (query: string) => string[];
    results: (query: string, text: string) => string[];
    lines: (query: string, text: string) => string[];
}>;
export { index$4 as convert, index$3 as fsw, index$2 as fswquery, index$5 as style, index$1 as swu, index as swuquery };
/**
 * Object of query elements with regular expression identification.
 */
type QueryObject = {
    /**
     * - required true for query object
     */
    query: boolean;
    /**
     * - an object for prefix elements
     */
    prefix?: {
        required: boolean;
        parts?: (string | string[] | (string | string[])[])[];
    };
    /**
     * - array of objects for symbols, ranges, and list of symbols or ranges, with optional coordinates
     */
    signbox?: (QuerySignboxSymbol | QuerySignboxRange | QuerySignboxOr)[];
    /**
     * - amount that x or y coordinates can vary and find a match, defaults to 20
     */
    variance?: number;
    /**
     * - boolean value for including style string in matches
     */
    style?: boolean;
};
type QuerySignboxSymbol = {
    /**
     * - a symbol
     */
    symbol: string;
    /**
     * - an optional coordinate
     */
    coord?: number[];
};
type QuerySignboxRange = {
    /**
     * - an array of two symbols
     */
    range: string[];
    /**
     * - an optional coordinate
     */
    coord?: number[];
};
type QuerySignboxOr = {
    /**
     * - an array of symbol strings and range arrays
     */
    or: (string | string[])[];
    /**
     * - an optional coordinate
     */
    coord?: number[];
};
type ColumnOptions = {
    /**
     * - the height of the columns
     */
    height?: number;
    /**
     * - the widths of the columns
     */
    width?: number;
    /**
     * - the lane offset for left and right lanes
     */
    offset?: number;
    /**
     * - amount of padding before and after signs as well as at top, left, and right of columns
     */
    pad?: number;
    /**
     * - amount of space at bottom of column that is not available
     */
    margin?: number;
    /**
     * - enables variable width columns
     */
    dynamic?: boolean;
    /**
     * - background color for columns
     */
    background?: string;
    /**
     * - an object of style options
     */
    style?: StyleObject;
    /**
     * - an object of punctuation options
     */
    punctuation?: {
        spacing?: boolean;
        pad?: number;
        pull?: boolean;
    };
};
type ColumnData = ColumnSegment[];
type ColumnSegment = {
    /**
     * - the x position in the column
     */
    x: number;
    /**
     * - the y position in the column
     */
    y: number;
    /**
     * - the min x value within the segment
     */
    minX: number;
    /**
     * - the min y value within the segment
     */
    minY: number;
    /**
     * - the width of the text segment
     */
    width: number;
    /**
     * - the height of the text segment
     */
    height: number;
    /**
     * - Left as -1, Middle as 0, Right as 1
     */
    lane: number;
    /**
     * - the padding of the text segment affects colored background
     */
    padding: number;
    /**
     * - "sign" or "symbol"
     */
    segment: string;
    /**
     * - the text of the sign or symbol with optional style string
     */
    text: string;
    /**
     * - the zoom size of the segment
     */
    zoom: number;
};
type SegmentInfo = {
    /**
     * - the min x value within the segment
     */
    minX: number;
    /**
     * - the min y value within the segment
     */
    minY: number;
    /**
     * - the width of the text segment
     */
    width: number;
    /**
     * - the height of the text segment
     */
    height: number;
    /**
     * - Left as -1, Middle as 0, Right as 1
     */
    lane: number;
    /**
     * - the padding of the text segment affects colored background
     */
    padding: number;
    /**
     * - "sign" or "symbol"
     */
    segment: string;
    /**
     * - the zoom size of the segment
     */
    zoom: number;
};
/**
 * The elements of a style string
 */
type StyleObject = {
    /**
     * - boolean to use standardized colors for symbol groups
     */
    colorize?: boolean;
    /**
     * - integer value for padding around symbol or sign
     */
    padding?: number;
    /**
     * - css name or hex color for background
     */
    background?: string;
    /**
     * - array for css name or hex color for line and optional fill
     */
    detail?: string[];
    /**
     * - decimal value for zoom level
     */
    zoom?: number;
    /**
     * - custom colors for individual symbols
     */
    detailsym?: {
        index: number;
        detail: string[];
    };
    /**
     * - list of class names separated with spaces used for SVG
     */
    classes?: string;
    /**
     * - id name used for SVG
     */
    id?: string;
};
/**
 * The elements of a symbol string
 */
type SymbolObject = {
    /**
     * - symbol identifier
     */
    symbol?: string;
    /**
     * - x,y coordinate
     */
    coord?: number[];
    /**
     * - style string
     */
    style?: string;
};
/**
 * The elements of a sign string
 */
type SignObject = {
    /**
     * - array of symbols
     */
    sequence?: string[];
    /**
     * - signbox marker or lane
     */
    box?: string;
    /**
     * - preprocessed x,y coordinate
     */
    max?: number[];
    /**
     * - array of symbols with coordinates
     */
    spatials?: {
        symbol: string;
        coord: number[];
    }[];
    /**
     * - style string
     */
    style?: string;
};
